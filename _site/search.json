[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About me",
    "section": "",
    "text": "My name is Claudius Gräbner-Radkowitsch and I am interested in the functioning of globalization and technological change, and how they affect socio-economic development.\nMy general motivation to work as an economist still comes from the time when I was working as a streetworker in Chiapas, Mexico, after completing my A-levels. Since then I want to understand better how the living standards of people all over the world can be improved in a sustainable way. This is of course a broad, idealist and intricate goal. But it keeps me motivated.\nThe applied topics that interest me align poorly with disciplinary boundaries, and many relevant lessons can only be learned in practice. Thus, I am convinced that new insights come from academics and practitioners, and people with various disciplinary backgrounds, working collectively and cooperatively together. I try to practice this conviction in my work as best as I can.\nAside from these applied topics I am also interested in the philosophy of economics. Thinking and writing about about questions such as “How do I actually derive insights from a mathematical model?” or “How do I compare a model composed of formulas with an economy composed of human beings?” helps me to put my results and work into context, and to remain open to debate with those who think very differently. Correspondingly, I am also interested in the ongoing debate about pluralism in economics, and I sometimes think and write about the conditions under which pluralism is - in my view - desirable, and what the associated challenges are.\nIf you are also interested in such questions you might want to have a look at my research, or contact me to articulate questions, recommendations or critique."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Claudius Gräbner-Radkowitsch",
    "section": "",
    "text": "My name is Claudius Gräbner-Radkowitsch and I am an economist working as a Junior Professor (W1TT) at the Europa University Flensburg (Germany) and as a research associate at the Institute of Comprehensive Analysis of the Economy (ICAE) of the Johannes Kepler University Linz (Austria). I am also a research fellow of the Institute for future-fit economies (ZOE) .\nMy research is mainly concerned with the socio-economic effects of globalization, the determinants for international competitiveness, economic complexity, institutions and socio-economic development. Besides, I am also interested in economic methodology, in particular how economic models can be helpful in understanding real economic systems.\nOn this homepage I provide some information and material about the research projects I am responsible for, my teaching and lecturing activities, my research, and myself."
  },
  {
    "objectID": "index.html#bio",
    "href": "index.html#bio",
    "title": "Claudius Gräbner-Radkowitsch",
    "section": "",
    "text": "My name is Claudius Gräbner-Radkowitsch and I am an economist working as a Junior Professor (W1TT) at the Europa University Flensburg (Germany) and as a research associate at the Institute of Comprehensive Analysis of the Economy (ICAE) of the Johannes Kepler University Linz (Austria). I am also a research fellow of the Institute for future-fit economies (ZOE) .\nMy research is mainly concerned with the socio-economic effects of globalization, the determinants for international competitiveness, economic complexity, institutions and socio-economic development. Besides, I am also interested in economic methodology, in particular how economic models can be helpful in understanding real economic systems.\nOn this homepage I provide some information and material about the research projects I am responsible for, my teaching and lecturing activities, my research, and myself."
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "A blog about computational aspects of economic research",
    "section": "",
    "text": "This is my blog. I use it mainly to post some simple receipts for computational (and sometimes intellectual) challenges - some smaller, some bigger - that I encounter in my daily life. I hope some of these comments are useful for others as well.\n\n\n\n\n\n\n\n\n\n\n\n\nVirtual environments in Python using conda\n\n\n\nPython\n\n\n\nExplains why virtual environments are essential when working on scientific projects and how to manage them in Python using conda.\n\n\n\nClaudius Gräbner-Radkowitsch\n\n\nJan 30, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2024-01-30-virtenvs-conda/index.html",
    "href": "posts/2024-01-30-virtenvs-conda/index.html",
    "title": "Virtual environments in Python using conda",
    "section": "",
    "text": "One can think of an virtual environment as a self-contained space that has its own Python interpreter and packages. If you install a new package from within the environment, the package and the dependencies are installed only for this environment. Once you leave the environment the package is not available. Also if you update Python or any other package within the environment, the versions outside of the envirvonment remain unchanged. Conversely, updates made outside the environment do not affect the packages and Python versions within the environment.\nWhen conducting a scientific project using Python, using such virtual environments makes a lot of sense. In fact, it is usually a good idea to create one virtual environment for each or your projects."
  },
  {
    "objectID": "posts/2024-01-30-virtenvs-conda/index.html#how-to-delete-an-environment",
    "href": "posts/2024-01-30-virtenvs-conda/index.html#how-to-delete-an-environment",
    "title": "Virtual environments in Python using conda",
    "section": "How to delete an environment",
    "text": "How to delete an environment\nIf you want to delete an environment you do not longer need you can do this via\nconda remove -n ENVNAME -all\nbut you should be careful with this."
  },
  {
    "objectID": "posts/2024-01-30-virtenvs-conda/index.html#create-environments-with-specified-packages-and-package-version",
    "href": "posts/2024-01-30-virtenvs-conda/index.html#create-environments-with-specified-packages-and-package-version",
    "title": "Virtual environments in Python using conda",
    "section": "Create environments with specified packages and package version",
    "text": "Create environments with specified packages and package version\nFor obvious reasons you might want to specify the particular versions of the packages you use in a new environment. The syntax to do so is straightforward and follows the following pattern:\nconda create -n myenv python=3.6 scipy=0.15.0 pandas\nThis creates a new environment called ‘myenv’ with Python version 3.6, the package scipi in version 0.15.0 and the package pandas in the most recent version available."
  },
  {
    "objectID": "posts/2024-01-30-virtenvs-conda/index.html#what-if-the-environment-cannot-be-registered",
    "href": "posts/2024-01-30-virtenvs-conda/index.html#what-if-the-environment-cannot-be-registered",
    "title": "Virtual environments in Python using conda",
    "section": "What if the environment cannot be registered?",
    "text": "What if the environment cannot be registered?\nIn case you get a warning that the environment cannot be registered because the path .envs is not writable either make it writable using chmod or create the environment using admin rights, i.e. using the sudo command. The latter is not recommended. On macOS the writing allowance might be wrong, so you need to give you writing allowance:\nsudo chown -R username /home/username/path-to-conda-folder/\n\nsudo chmod -R +x /home/username/path-to-conda-folder/\nAdjust the directories according to the warnings that are provided it you install an environment as described below."
  },
  {
    "objectID": "posts/2024-01-30-virtenvs-conda/index.html#how-to-save-the-environment-in-a-.yml-file",
    "href": "posts/2024-01-30-virtenvs-conda/index.html#how-to-save-the-environment-in-a-.yml-file",
    "title": "Virtual environments in Python using conda",
    "section": "How to save the environment in a .yml file",
    "text": "How to save the environment in a .yml file\nTo save the versions of all relevant packages and to recover the virtual environment when needed you can save the relevant information in a file from which you can later re-create the environment anew.\nTo save the current environment in a file environment.yml do:\nconda env export &gt; environment.yml\nAcross platforms you may not want to include all packages, but only those that you installed explicitly (thereby excluding platform-specific dependencies):\n conda env export --from-history  &gt; environment.yml\nTo create a new environment from an existing file environment.yml file simply call:\nconda env create -f environment.yml\nNote that the name of the new environment is determined by the .yml (first line)."
  },
  {
    "objectID": "research/projects/index.html",
    "href": "research/projects/index.html",
    "title": "Projects",
    "section": "",
    "text": "These are the ‘official’ projects.\n\n\n\n\nFunded by the German Science Foundation (DFG) and the Polish National Science Center (NCN)\nProjekt homepage\n\n\n\nTime period:\nOctober 2023 - September 2026\n\n\nFunding sum:\n295.000 EUR (German part)\n\n\nMy role:\nPrincipal investigator\n\n\n\n\n\n\nFunded by the Austrian National Science Fund (FWF)\nProjekt homepage\n\n\n\nTime period:\nJune 2019 - April 2024\n\n\nFunding sum:\n2.5 Mio EUR\n\n\nMy role:\nOne of five principal investigators\n\n\n\n\n\n\n\n\n\nFunded by the Austrian National Bank (OeNB)\nProjekt homepage\n\n\n\nTime period:\nJanuary 2020 - August 2021\n\n\nFunding sum:\n107.000 EUR\n\n\nMy role:\nPrincipal investigator\n\n\n\n\n\n\nFunded by the National Institute of Economic and Social Research (UK)\nProjekt homepage\n\n\n\nTime period:\nMay 2019 - October 2020\n\n\nFunding sum:\n80.000 EUR\n\n\nMy role:\nPrincipal investigator\n\n\n\n\n\n\nFunded by the Friedrich-EbertStiftung\nProjekt homepage\n\n\n\nTime period:\nJanuary 2019 - June 2019\n\n\nFunding sum:\n10.000 EUR\n\n\nMy role:\nPost-Doc researcher\n\n\n\n\n\n\nFunded by the Austrian National Bank (OeNB)\nProjekt homepage\n\n\n\nTime period:\nApril 2017 - June 2019\n\n\nFunding sum:\n191.400 EUR\n\n\nMy role:\nPost-Doc researcher"
  },
  {
    "objectID": "research/projects/index.html#current-projects",
    "href": "research/projects/index.html#current-projects",
    "title": "Projects",
    "section": "",
    "text": "Funded by the German Science Foundation (DFG) and the Polish National Science Center (NCN)\nProjekt homepage\n\n\n\nTime period:\nOctober 2023 - September 2026\n\n\nFunding sum:\n295.000 EUR (German part)\n\n\nMy role:\nPrincipal investigator\n\n\n\n\n\n\nFunded by the Austrian National Science Fund (FWF)\nProjekt homepage\n\n\n\nTime period:\nJune 2019 - April 2024\n\n\nFunding sum:\n2.5 Mio EUR\n\n\nMy role:\nOne of five principal investigators"
  },
  {
    "objectID": "research/projects/index.html#completed-projects",
    "href": "research/projects/index.html#completed-projects",
    "title": "Projects",
    "section": "",
    "text": "Funded by the Austrian National Bank (OeNB)\nProjekt homepage\n\n\n\nTime period:\nJanuary 2020 - August 2021\n\n\nFunding sum:\n107.000 EUR\n\n\nMy role:\nPrincipal investigator\n\n\n\n\n\n\nFunded by the National Institute of Economic and Social Research (UK)\nProjekt homepage\n\n\n\nTime period:\nMay 2019 - October 2020\n\n\nFunding sum:\n80.000 EUR\n\n\nMy role:\nPrincipal investigator\n\n\n\n\n\n\nFunded by the Friedrich-EbertStiftung\nProjekt homepage\n\n\n\nTime period:\nJanuary 2019 - June 2019\n\n\nFunding sum:\n10.000 EUR\n\n\nMy role:\nPost-Doc researcher\n\n\n\n\n\n\nFunded by the Austrian National Bank (OeNB)\nProjekt homepage\n\n\n\nTime period:\nApril 2017 - June 2019\n\n\nFunding sum:\n191.400 EUR\n\n\nMy role:\nPost-Doc researcher"
  },
  {
    "objectID": "research/publications/index.html",
    "href": "research/publications/index.html",
    "title": "Publications",
    "section": "",
    "text": "Glassmann U., Gräbner-Radkowitsch C. (Eds.) (2024). The Political Economy of Italy and the Center-Periphery Perspective on Europe. Marburg: Metropolis. Available online.\nGräbner-Radkowitsch C., Kapeller J. (2024). Development Models in the EU: Opportunities and Challenges, in: Glassmann U., Gräbner-Radkowitsch C. (Eds.): The Political Economy of Italy and the Center-Periphery Perspective on Europe. Marburg: Metropolis, pp. 49–79.\nKapeller J., Gräbner-Radkowitsch C., Hornykewycz A. (2024). Corporate power and global value chains: current approaches for conceptualizing the power of multinationals, Review of Evolutionary Political Economy. doi: 10.1007/s43253-024-00121-5\n\n\n\n\n\nGräbner-Radkowitsch C., Strunk B. (2023). Degrowth and the Global South: The Twin Problem of Global Dependencies, Ecological Economics, 213: 107946. doi: 10.1016/j.ecolecon.2023.107946\nGräbner-Radkowitsch C., Hager T., Hornykewycz A. (2023). Competing for Sustainability? An Institutionalist Analysis of the New Development Model of the European Union, Journal of Economic Issues, 57(2): 676–683. doi: 10.1080/00213624.2023.2203637\nGräbner-Radkowitsch C., Strunk B. (2023). Degrowth and the Global South? How Institutionalism Can Complement a Timely Discourse on Ecologically Sustainable Development in an Unequal World, Journal of Economic Issues, 57(2): 476–483. doi: 10.1080/00213624.2023.2201640\n\n\n\n\n\nGräbner-Radkowitsch C. (2022). Elements of an Evolutionary Approach to Comparative Economic Studies: Complexity, Systemism, and Path Dependent Development, in: Dallago B., Casagrande S. (Eds.): Routledge Handbook of Comparative Economic Systems. London and New York: Routledge, pp. 81–102.\nGräbner-Radkowitsch C., Heimberger P., Kapeller J., Landesmann M., Schütz B. (2022). The Evolution of Debtor-Creditor Relationships within a Monetary Union: Trade Imbalances, Excess Reserves and Economic Policy, Structural Change and Economic Dynamics, 62: 262–289. doi: 10.1016/j.strueco.2022.05.004\nGräbner-Radkowitsch C., Tamesberger D., Heimberger P., Kapelari T., Kapeller J. (2022). Trade Models in the European Union, Economic Annals, 67(235): 7–36. doi: 10.2298/eka2235007g\nGräbner-Radkowitsch C., Hafele J. (2022). Why Fostering Socio-economic Convergence in the EU Is Necessary for Successful Climate Change Mitigation, in: Heinrich Böll Foundation, ZOE-Institute for Future-Fit Economies, Finanzwende Recherche (Eds.): Making the Great Turnaround Work: Economic Policy for a Green and Just Transition. Berlin: Heinrich Böll Foundation, pp. 104–114.\nGräbner C., Hornykewycz A. (2022). Capability Accumulation and Product Innovation: An Agent-Based Perspective, Journal of Evolutionary Economics, 32(1): 87–121. doi: 10.1007/s00191-021-00732-9\n\n\n\n\n\nAistleitner M., Gräbner C., Hornykewycz A. (2021). Theory and Empirics of Capability Accumulation: Implications for Macroeconomic Modelling, Research Policy, 50(6): 104258. doi: 10.1016/j.respol.2021.104258\nCordes C., Elsner W., Graebner C., Heinrich T., Henkel J., Schwardt H., Schwesinger G., Su T. (2021). The Collapse of Cooperation: The Endogeneity of Institutional Break-up and Its Asymmetry with Emergence, Journal of Evolutionary Economics, 31(4): 1291–1315. doi: 10.1007/s00191-021-00739-2\nGräbner C., Heimberger P., Kapeller J., Springholz F. (2021). Understanding Economic Openness: A Review of Existing Measures, Review of World Economics, 157(1): 87–120. doi: 10.1007/s10290-020-00391-1\nKapeller J., Gräbner C. (2021). Konzernmacht in Globalen Güterketten, in: Fischer K., Reiner C., Staritz C. (Eds.): Globale Warenketten Und Ungleiche Entwicklung. Arbeit, Kapital, Konsum, Natur. Wien: mandelbaum verlag, pp. 195–213.\nKapeller J., Gräbner-Radkowitsch C. (2021). Standortwettbewerb Und Deindustrialisierung: Das Beispiel MAN Als Lehrbuchfall, WISO, 44(4): 33–52.\n\n\n\n\n\nGräbner C., Heimberger P., Kapeller J., Schütz B. (2020). Is the Eurozone Disintegrating? Macroeconomic Divergence, Structural Polarisation, Trade and Fragility, Cambridge Journal of Economics, 44(3): 647–669. doi: 10.1093/cje/bez059\nGräbner C., Heimberger P., Kapeller J. (2020). Pandemic Pushes Polarisation: The Corona Crisis and Macroeconomic Divergence in the Eurozone, Journal of Industrial and Business Economics, 47(3): 425–438. doi: 10.1007/s40812-020-00163-w\nGräbner C., Strunk B. (2020). Pluralism in Economics: Its Critiques and Their Lessons, Journal of Economic Methodology, 27(4): 311–329. doi: 10.1080/1350178x.2020.1824076\nGräbner C., Heimberger P., Kapeller J., Schütz B. (2020). Structural Change in Times of Increasing Openness: Assessing Path Dependency in European Economic Integration, Journal of Evolutionary Economics, 30(5): 1467–1495. doi: 10.1007/s00191-019-00639-6\nGräbner C., Elsner W., Lascaux A. (2020). Trust and Social Control: Sources of Cooperation, Performance, and Stability in Informal Value Transfer Systems, Computational Economics: 1–26. doi: 10.1007/s10614-020-09994-0\n\n\n\n\n\nFlechtner S., Gräbner C. (2019). The Heterogeneous Relationship between Income and Inequality: A Panel Co-Integration Approach, Economics Bulletin, 39(4): 2540–2549.\nGräbner C., Bale C., Furtado B., Pereira B., Gentile J., Henderson H., Lipari F. (2019). Getting the Best of Both Worlds? Developing Complementary Equation-Based and Agent-Based Models, Computational Economics, 53(2): 763–782. doi: 10.1007/s10614-017-9763-8\nHeinrich T., Gräbner C. (2019). Beyond Equilibrium: Revisiting Two-Sided Markets from an Agent-Based Modelling Perspective, International Journal of Computational Economics and Econometrics, 9(3): 153–180. doi: 10.1504/ijcee.2019.100558\nKapeller J., Gräbner C., Heimberger P. (2019). Economic Polarisation in Europe: Causes and Policy Options, wiiw Research Report, 440.\nKapeller J., Gräbner C., Heimberger P. (2019). Wirtschaftliche Polarisierung in Europa. Berlin: Friedrich-Ebert-Stiftung. Available online.\n\n\n\n\n\nGräbner C., Heinrich T., Kudic M., Vermeulen B. (2018). The Dynamics of and on Networks: An Introduction, International Journal of Computational Economics and Econometrics, 8(3/4): 229–241.\nGräbner C. (2018). Formal Approaches to Socio-economic Analysis—Past and Perspectives, Forum for Social Economics, 47(1): 32–63. doi: 10.1080/07360932.2015.1042491\nGräbner C. (2018). How to Relate Models to Reality? An Epistemological Framework for the Validation and Verification of Computational Models, Journal of Artificial Societies and Simulation, 21(3). doi: 10.18564/jasss.3772\nGräbner C., Heimberger P., Kapeller J., Springholz F. (2018). Measuring Economic Openness: A Review of Existing Measurements and Empirical Practices, ICAE Working Paper, 84.\nGräbner C., Elsner W., Lascaux A. (2018). To Trust or to Control: Informal Value Transfer Systems and Computational Analysis in Institutional Economics, Journal of Economic Issues, 52(2): 559–569. doi: 10.1080/00213624.2018.1469936\n\n\n\n\n\nGräbner C. (2017). The Complementary Relationship Between Institutional and Complexity Economics: The Example of Deep Mechanismic Explanations, Journal of Economic Issues, 51(2): 392–400. doi: 10.1080/00213624.2017.1320915\nGräbner C. (2017). The Complexity of Economies and Pluralism in Economics, Journal of Contextual Economics, 137(3): 193–225. doi: 10.3790/jce.137.3.193\nGräbner C. (2017). Dealing Adequately with the Political Element in Formal Modelling, in: Hanappi H., Katsikides S., Scholz-Wäckerle M. (Eds.): Theory and Method of Evolutionary Political Economy. London: Routledge, pp. 236–254.\nGräbner C., Kapeller J. (2017). The Micro-Macro Link in Heterodox Economics, in: Jo T., Chester L., D’Ippolliti C. (Eds.): The Handbook of Heterodox Economics. London, UK, New York, NY: Routledge, pp. 145–159.\nGräbner C., Heinrich T. (2017). Von Onlineplattformen Und Mittelalterlichen Märkten, TATuP Zeitschrift für Technikfolgenabschätzung in Theorie und Praxis, 26(3): 23–29. doi: 10.14512/tatup.26.3.23\nGräbner C. (2017). Die Rolle Des Gleichgewichtskonzepts in Der Mikroökonomischen Ausbildung, in: van Treeck T., Urban J. (Eds.): Wirtschaft Neu Denken. Berlin: iRights media, pp. 60–73.\n\n\n\n\n\nGräbner C. (2016). Agent-Based Computational Models– a Formal Heuristic for Institutionalist Pattern Modelling?, Journal of Institutional Economics, 12(1): 241–261. doi: 10.1017/s1744137415000193\nGräbner C., Heinrich T., Schwardt H. (Eds.) (2016). Policy Implications of Recent Advances in Evolutionary and Institutional Economics. New York: Routledge.\nPereira B., Henderson H., Lipari F., Furtado B., Bale C., Gentile J., Gräbner C. (2016). Errata in ``The Political Economy of the Kuznets Curve’’, Review of Development Economics, 20(4): 817–819. doi: 10.1111/rode.12285\nSchwardt H., Gräbner C., Heinrich T., Cordes C., Schwesinger G. (2016). Economic Complexity and Trade-Offs in Policy Decisions, in: Gräbner C., Heinrich T., Schwardt H. (Eds.): Policy Implications of Recent Advances in Evolutionary and Institutional Economics. London and New York: Routledge, pp. 3–19.\n\n\n\n\n\nGräbner C., Kapeller J. (2015). New Perspectives on Institutionalist Pattern Modeling: Systemism, Complexity, and Agent-Based Modeling, Journal of Economic Issues, 49(2): 433–440. doi: 10.1080/00213624.2015.1042765"
  },
  {
    "objectID": "research/publications/index.html#section",
    "href": "research/publications/index.html#section",
    "title": "Publications",
    "section": "",
    "text": "Glassmann U., Gräbner-Radkowitsch C. (Eds.) (2024). The Political Economy of Italy and the Center-Periphery Perspective on Europe. Marburg: Metropolis. Available online.\nGräbner-Radkowitsch C., Kapeller J. (2024). Development Models in the EU: Opportunities and Challenges, in: Glassmann U., Gräbner-Radkowitsch C. (Eds.): The Political Economy of Italy and the Center-Periphery Perspective on Europe. Marburg: Metropolis, pp. 49–79.\nKapeller J., Gräbner-Radkowitsch C., Hornykewycz A. (2024). Corporate power and global value chains: current approaches for conceptualizing the power of multinationals, Review of Evolutionary Political Economy. doi: 10.1007/s43253-024-00121-5"
  },
  {
    "objectID": "research/publications/index.html#section-1",
    "href": "research/publications/index.html#section-1",
    "title": "Publications",
    "section": "",
    "text": "Gräbner-Radkowitsch C., Strunk B. (2023). Degrowth and the Global South: The Twin Problem of Global Dependencies, Ecological Economics, 213: 107946. doi: 10.1016/j.ecolecon.2023.107946\nGräbner-Radkowitsch C., Hager T., Hornykewycz A. (2023). Competing for Sustainability? An Institutionalist Analysis of the New Development Model of the European Union, Journal of Economic Issues, 57(2): 676–683. doi: 10.1080/00213624.2023.2203637\nGräbner-Radkowitsch C., Strunk B. (2023). Degrowth and the Global South? How Institutionalism Can Complement a Timely Discourse on Ecologically Sustainable Development in an Unequal World, Journal of Economic Issues, 57(2): 476–483. doi: 10.1080/00213624.2023.2201640"
  },
  {
    "objectID": "research/publications/index.html#section-2",
    "href": "research/publications/index.html#section-2",
    "title": "Publications",
    "section": "",
    "text": "Gräbner-Radkowitsch C. (2022). Elements of an Evolutionary Approach to Comparative Economic Studies: Complexity, Systemism, and Path Dependent Development, in: Dallago B., Casagrande S. (Eds.): Routledge Handbook of Comparative Economic Systems. London and New York: Routledge, pp. 81–102.\nGräbner-Radkowitsch C., Heimberger P., Kapeller J., Landesmann M., Schütz B. (2022). The Evolution of Debtor-Creditor Relationships within a Monetary Union: Trade Imbalances, Excess Reserves and Economic Policy, Structural Change and Economic Dynamics, 62: 262–289. doi: 10.1016/j.strueco.2022.05.004\nGräbner-Radkowitsch C., Tamesberger D., Heimberger P., Kapelari T., Kapeller J. (2022). Trade Models in the European Union, Economic Annals, 67(235): 7–36. doi: 10.2298/eka2235007g\nGräbner-Radkowitsch C., Hafele J. (2022). Why Fostering Socio-economic Convergence in the EU Is Necessary for Successful Climate Change Mitigation, in: Heinrich Böll Foundation, ZOE-Institute for Future-Fit Economies, Finanzwende Recherche (Eds.): Making the Great Turnaround Work: Economic Policy for a Green and Just Transition. Berlin: Heinrich Böll Foundation, pp. 104–114.\nGräbner C., Hornykewycz A. (2022). Capability Accumulation and Product Innovation: An Agent-Based Perspective, Journal of Evolutionary Economics, 32(1): 87–121. doi: 10.1007/s00191-021-00732-9"
  },
  {
    "objectID": "research/publications/index.html#section-3",
    "href": "research/publications/index.html#section-3",
    "title": "Publications",
    "section": "",
    "text": "Aistleitner M., Gräbner C., Hornykewycz A. (2021). Theory and Empirics of Capability Accumulation: Implications for Macroeconomic Modelling, Research Policy, 50(6): 104258. doi: 10.1016/j.respol.2021.104258\nCordes C., Elsner W., Graebner C., Heinrich T., Henkel J., Schwardt H., Schwesinger G., Su T. (2021). The Collapse of Cooperation: The Endogeneity of Institutional Break-up and Its Asymmetry with Emergence, Journal of Evolutionary Economics, 31(4): 1291–1315. doi: 10.1007/s00191-021-00739-2\nGräbner C., Heimberger P., Kapeller J., Springholz F. (2021). Understanding Economic Openness: A Review of Existing Measures, Review of World Economics, 157(1): 87–120. doi: 10.1007/s10290-020-00391-1\nKapeller J., Gräbner C. (2021). Konzernmacht in Globalen Güterketten, in: Fischer K., Reiner C., Staritz C. (Eds.): Globale Warenketten Und Ungleiche Entwicklung. Arbeit, Kapital, Konsum, Natur. Wien: mandelbaum verlag, pp. 195–213.\nKapeller J., Gräbner-Radkowitsch C. (2021). Standortwettbewerb Und Deindustrialisierung: Das Beispiel MAN Als Lehrbuchfall, WISO, 44(4): 33–52."
  },
  {
    "objectID": "research/publications/index.html#section-4",
    "href": "research/publications/index.html#section-4",
    "title": "Publications",
    "section": "",
    "text": "Gräbner C., Heimberger P., Kapeller J., Schütz B. (2020). Is the Eurozone Disintegrating? Macroeconomic Divergence, Structural Polarisation, Trade and Fragility, Cambridge Journal of Economics, 44(3): 647–669. doi: 10.1093/cje/bez059\nGräbner C., Heimberger P., Kapeller J. (2020). Pandemic Pushes Polarisation: The Corona Crisis and Macroeconomic Divergence in the Eurozone, Journal of Industrial and Business Economics, 47(3): 425–438. doi: 10.1007/s40812-020-00163-w\nGräbner C., Strunk B. (2020). Pluralism in Economics: Its Critiques and Their Lessons, Journal of Economic Methodology, 27(4): 311–329. doi: 10.1080/1350178x.2020.1824076\nGräbner C., Heimberger P., Kapeller J., Schütz B. (2020). Structural Change in Times of Increasing Openness: Assessing Path Dependency in European Economic Integration, Journal of Evolutionary Economics, 30(5): 1467–1495. doi: 10.1007/s00191-019-00639-6\nGräbner C., Elsner W., Lascaux A. (2020). Trust and Social Control: Sources of Cooperation, Performance, and Stability in Informal Value Transfer Systems, Computational Economics: 1–26. doi: 10.1007/s10614-020-09994-0"
  },
  {
    "objectID": "research/publications/index.html#section-5",
    "href": "research/publications/index.html#section-5",
    "title": "Publications",
    "section": "",
    "text": "Flechtner S., Gräbner C. (2019). The Heterogeneous Relationship between Income and Inequality: A Panel Co-Integration Approach, Economics Bulletin, 39(4): 2540–2549.\nGräbner C., Bale C., Furtado B., Pereira B., Gentile J., Henderson H., Lipari F. (2019). Getting the Best of Both Worlds? Developing Complementary Equation-Based and Agent-Based Models, Computational Economics, 53(2): 763–782. doi: 10.1007/s10614-017-9763-8\nHeinrich T., Gräbner C. (2019). Beyond Equilibrium: Revisiting Two-Sided Markets from an Agent-Based Modelling Perspective, International Journal of Computational Economics and Econometrics, 9(3): 153–180. doi: 10.1504/ijcee.2019.100558\nKapeller J., Gräbner C., Heimberger P. (2019). Economic Polarisation in Europe: Causes and Policy Options, wiiw Research Report, 440.\nKapeller J., Gräbner C., Heimberger P. (2019). Wirtschaftliche Polarisierung in Europa. Berlin: Friedrich-Ebert-Stiftung. Available online."
  },
  {
    "objectID": "research/publications/index.html#section-6",
    "href": "research/publications/index.html#section-6",
    "title": "Publications",
    "section": "",
    "text": "Gräbner C., Heinrich T., Kudic M., Vermeulen B. (2018). The Dynamics of and on Networks: An Introduction, International Journal of Computational Economics and Econometrics, 8(3/4): 229–241.\nGräbner C. (2018). Formal Approaches to Socio-economic Analysis—Past and Perspectives, Forum for Social Economics, 47(1): 32–63. doi: 10.1080/07360932.2015.1042491\nGräbner C. (2018). How to Relate Models to Reality? An Epistemological Framework for the Validation and Verification of Computational Models, Journal of Artificial Societies and Simulation, 21(3). doi: 10.18564/jasss.3772\nGräbner C., Heimberger P., Kapeller J., Springholz F. (2018). Measuring Economic Openness: A Review of Existing Measurements and Empirical Practices, ICAE Working Paper, 84.\nGräbner C., Elsner W., Lascaux A. (2018). To Trust or to Control: Informal Value Transfer Systems and Computational Analysis in Institutional Economics, Journal of Economic Issues, 52(2): 559–569. doi: 10.1080/00213624.2018.1469936"
  },
  {
    "objectID": "research/publications/index.html#section-7",
    "href": "research/publications/index.html#section-7",
    "title": "Publications",
    "section": "",
    "text": "Gräbner C. (2017). The Complementary Relationship Between Institutional and Complexity Economics: The Example of Deep Mechanismic Explanations, Journal of Economic Issues, 51(2): 392–400. doi: 10.1080/00213624.2017.1320915\nGräbner C. (2017). The Complexity of Economies and Pluralism in Economics, Journal of Contextual Economics, 137(3): 193–225. doi: 10.3790/jce.137.3.193\nGräbner C. (2017). Dealing Adequately with the Political Element in Formal Modelling, in: Hanappi H., Katsikides S., Scholz-Wäckerle M. (Eds.): Theory and Method of Evolutionary Political Economy. London: Routledge, pp. 236–254.\nGräbner C., Kapeller J. (2017). The Micro-Macro Link in Heterodox Economics, in: Jo T., Chester L., D’Ippolliti C. (Eds.): The Handbook of Heterodox Economics. London, UK, New York, NY: Routledge, pp. 145–159.\nGräbner C., Heinrich T. (2017). Von Onlineplattformen Und Mittelalterlichen Märkten, TATuP Zeitschrift für Technikfolgenabschätzung in Theorie und Praxis, 26(3): 23–29. doi: 10.14512/tatup.26.3.23\nGräbner C. (2017). Die Rolle Des Gleichgewichtskonzepts in Der Mikroökonomischen Ausbildung, in: van Treeck T., Urban J. (Eds.): Wirtschaft Neu Denken. Berlin: iRights media, pp. 60–73."
  },
  {
    "objectID": "research/publications/index.html#section-8",
    "href": "research/publications/index.html#section-8",
    "title": "Publications",
    "section": "",
    "text": "Gräbner C. (2016). Agent-Based Computational Models– a Formal Heuristic for Institutionalist Pattern Modelling?, Journal of Institutional Economics, 12(1): 241–261. doi: 10.1017/s1744137415000193\nGräbner C., Heinrich T., Schwardt H. (Eds.) (2016). Policy Implications of Recent Advances in Evolutionary and Institutional Economics. New York: Routledge.\nPereira B., Henderson H., Lipari F., Furtado B., Bale C., Gentile J., Gräbner C. (2016). Errata in ``The Political Economy of the Kuznets Curve’’, Review of Development Economics, 20(4): 817–819. doi: 10.1111/rode.12285\nSchwardt H., Gräbner C., Heinrich T., Cordes C., Schwesinger G. (2016). Economic Complexity and Trade-Offs in Policy Decisions, in: Gräbner C., Heinrich T., Schwardt H. (Eds.): Policy Implications of Recent Advances in Evolutionary and Institutional Economics. London and New York: Routledge, pp. 3–19."
  },
  {
    "objectID": "research/publications/index.html#section-9",
    "href": "research/publications/index.html#section-9",
    "title": "Publications",
    "section": "",
    "text": "Gräbner C., Kapeller J. (2015). New Perspectives on Institutionalist Pattern Modeling: Systemism, Complexity, and Agent-Based Modeling, Journal of Economic Issues, 49(2): 433–440. doi: 10.1080/00213624.2015.1042765"
  },
  {
    "objectID": "research/publications/index.html#section-10",
    "href": "research/publications/index.html#section-10",
    "title": "Publications",
    "section": "2024",
    "text": "2024\n\nGräbner-Radkowitsch C., Lage J., Wiese F. (2024). On the Economic Significance of Sufficiency, in: Economists4Future Blog, April: Link.\nGräbner-Radkowitsch C., Strunk B. (2024). Quelle Place Pour Le Sud Global Dans La D'ecroissance?, in: The Conversation, March: Link."
  },
  {
    "objectID": "research/publications/index.html#section-11",
    "href": "research/publications/index.html#section-11",
    "title": "Publications",
    "section": "2023",
    "text": "2023\n\nGräbner-Radkowitsch C., Strunk B. (2023). Degrowth and the Global South: Remarks on the Twin Problem of Structural Interdependencies, in: Developing Economics, November: Link.\nGräbner-Radkowitsch C., Strunk B. (2023). Degrowth Und Der Globale Süden, in: Postwachstum Blog, October: Link."
  },
  {
    "objectID": "research/publications/index.html#section-12",
    "href": "research/publications/index.html#section-12",
    "title": "Publications",
    "section": "2022",
    "text": "2022\n\nGräbner-Radkowitsch C., Lage J., Wiese F. (2022). Zur Ökonomischen Bedeutung von Suffizienz, in: Makronom – Online Magazin für Wirtschaftspolitik, June: Link."
  },
  {
    "objectID": "research/publications/index.html#section-13",
    "href": "research/publications/index.html#section-13",
    "title": "Publications",
    "section": "2021",
    "text": "2021\n\nAltreiter C., Rogojanu A., Gräbner C., Pühringer S., Wolfmayr G. (2021). 20 Jahre Gute Absichten in Der Wissenschaftspolitik, in: Die Presse, August: Link.\nAltreiter C., Rogojanu A., Gräbner C., Pühringer S., Wolfmayr G. (2021). Befristete Uni-Stellen: Drei Fehlschlüsse Mit Gravierenden Folgen, in: Der Standard, July: Link.\nGräbner-Radkowitsch C., Strunk B. (2021). Pluralism in Economics – Its Critiques and Their Lessons, in: Developing Economics, February: Link.\nGräbner-Radkowitsch C., Hafele J. (2021). What Are the Reasons for the Lack of Overall Convergence in the EU? A Structuralist View, in: The Rebuilding Macroeconomics Blog, April: Link.\nGräbner C., Heimberger P., Kapeller J., Schütz B. (2021). Ökonomische Offenheit: Die Vermessung Der Globalisierung, in: Oekonomenstimme, February: Link."
  },
  {
    "objectID": "research/publications/index.html#section-14",
    "href": "research/publications/index.html#section-14",
    "title": "Publications",
    "section": "2020",
    "text": "2020\n\nGräbner C., Strunk B. (2020). Kritik an Der Pluralen Ökonomik – Was Ist Dran Und Warum Ist Das Wichtig?, in: Oekonomenstimme, November: Link.\nHeimberger P., Gräbner C., Kapeller J., Schütz B. (2020). Die Vermessung Der Globalisierung, in: Makronom – Online Magazin für Wirtschaftspolitik, October: Link."
  },
  {
    "objectID": "research/publications/index.html#section-15",
    "href": "research/publications/index.html#section-15",
    "title": "Publications",
    "section": "2019",
    "text": "2019\n\nGräbner C., Heimberger P., Kapeller J., Schütz B. (2019). Eine Strategie Gegen Die Ökonomische Polarisierung Europas, in: Makronom – Online Magazin für Wirtschaftspolitik, July: Link.\nGräbner C. (2019). Why Europe Is Drifting Apart and What to Do about It, in: The Rebuilding Macroeconomics Blog, April: Link."
  },
  {
    "objectID": "research/publications/index.html#section-16",
    "href": "research/publications/index.html#section-16",
    "title": "Publications",
    "section": "2018",
    "text": "2018\n\nHeimberger P., Gräbner C., Kapeller J., Schütz B. (2018). Eine Strategie Gegen Die Ökonomische Polarisierung Europas, in: Makronom – Online Magazin für Wirtschaftspolitik, March: Link."
  },
  {
    "objectID": "research/wp/index.html",
    "href": "research/wp/index.html",
    "title": "Working paper",
    "section": "",
    "text": "Information about working papers can be found on the website of my department."
  },
  {
    "objectID": "talks/2019EAEPE-Complexity.html",
    "href": "talks/2019EAEPE-Complexity.html",
    "title": "The Political Economy of Economic Complexity: Models, Data and Policy",
    "section": "",
    "text": "This page contains all information and material for the workshop “The Political Economy of Economic Complexity: Models, Data and Policy” taught during the “Pre-Conference for Young Scholars”. Try to read into the core readings in advance, the other readings are optional.\n\nGeneral information about the course\nTentative course outline\nZip file with course readings\n\n\nLecture slides\nSection 1: Introduction & motivation: drivers of socio-economic development\nSection 2: Introducing the Economic Complexity Index (ECI)\nSection 3: Practical exercises and assessment of the complexity approach\nSection 4: Applications & discussion\n\n\nData sets for the practical exercises\nData on GDP (Source: World Bank)\n\n\nUseful links\nThe Atlas of Economic Complexity\nThe Observatory of Economic Complexity\nSome material is password protected for copyright reasons. The password is available upon request."
  },
  {
    "objectID": "talks/index.html",
    "href": "talks/index.html",
    "title": "Talks and presentations",
    "section": "",
    "text": "24.01.2024: Agent-based modelling and complexity economics (Agentenbasiertes Modellieren und Komplexitätsökonomik), Public lecture (University of Siegen, language: German).\n22.11.2024: The Plurality of Pluralist Economics (Die Pluralität der Pluralen Ökonomik), Public lecture (University of Hamburg, language: German).\n22.02.2024: Degrowth: Historical origins, the diversity of the movement and current controversies (Degrowth: Historische Ursprünge, die Vielfalt der Bewegung und aktuelle Kontroversen), Public lecture (Heinrich Böll Foundation, language: German).\n19.01.2024: Pluralism and Complexity: an alternative to the neoclassical equilibrium approach? (Pluralismus und Komplexität: Ein Gegenentwurf zur neoklassischen Gleichgewichtsökonomik?), Public lecture (University of Hamburg, language: German).\n\n\n\n\n\n07.02.2023: The Emergence of Debt and Secular Stagnation in an Unequal Society, Seminar Talk (Chemnitz University of Technology, language: English).\n14.11.2023: Pluralism and Decoloniality: Friends or Foes?, Public Lecture (University College London, language: English).\n23.01.2023: Agent-based modelling and complexity economics (Agentenbasiertes Modellieren und Komplexitätsökonomik), Public lecture (University of Siegen, language: German).\n\n\n\n\n\n29.09.2022: Applied Economic Methodology, Keynote given at the Second Philosophy & Economics Conference (University of Vienna, language: English).\n06.09.2022: Automation and Inequalities: The Merits of a Pluralist Research Program in the Context of Automation, Guest Lecture given at the EAEPE Pre-Conference for Young Scholars (Parthenope University of Naples, language: English).\n02.05.2022: Does the truth lie somewhere in between? A pluralist perspective on global inequality (Liegt die Wahrheit irgendwo dazwischen? Eine plurale Perspektive auf globale Ungleichheit), Public lecture (University of Tübingen, language: German).\n19.12.2022: The socioeconomic dimension of sufficiency: possible contributions from pluralist economics (Die sozioökonomischen Dimension von Suffizienz: Mögliche Beiträge der Pluralen Ökonomik), Invited presentation at the symposium on the socio-economic relevance of sufficiency (Europa-University Flensburg, language: German).\n\n\n\n\n\n29.05.2021: Challenges for pluralism in economics (Herausforderungen einer pluralen Ökonomik), Keynote (Spring school of the German Network for Pluralism in Economics, language: German).\n06.10.2021: Developing System Theory via Agent-Based Modeling, Invited Paper to the International Symposium on Theory Development through Agent-Based Modelling (Hannover, language: English).\n17.11.2021: Complexity Economics: an alternative to the neoclassical equilibrium approach? (Komplexitätsökonomik - Ein Gegenentwurf zur neoklassischen Gleichgewichtsökonomik?), Invited lecture (Zeppelin University, language: German).\n03.12.2021: Complexity Economics - A short introduction (Komplexitätsökonomik - Eine kurze Einführung), Invited lecture (FU Berlin, language: German).\n22.11.2024: The Plurality of Pluralism in Economics (Die Pluralität der Pluralen Ökonomik - Überlegungen zur Zukunft des Pluralismus in der VWL), Keynote at the symposium “The Future of Pluralist Economics” (University of Hamburg, language: German).\n19.10.2021: What is pluralist economics? (Was ist Plurale Ökonomik?), Inaugural speech to the public lecture series on pluralism in economics (Christian-Albrechts-University, language: German). Available on Youtube.\n16.12.2021: Pluralism in Economics & beyond - How a Plurality of Paradigms Helps Understanding Socio-Ecological Challenges, Invited Talk during the Sustainability and Energy Lectures (Europa-University Flensburg, language: English).\n09.06.2021 (together with Birte Strunk): Why we need pluralist economics (Warum braucht es Plurale Ökonomik?), Keynote (University of Vienna, language: German).\n\n\n\n\n\n02.09.2019: Pluralism, Complexity and the Effective Triangulation of Methods, Keynote (NEEC Summer Schoool on Complexity Economics, Behavioral Economics and Data Science at the University of Bochum, language: English).\n11.-12.09.2019: The Political Economy of Economic Complexity: Models, Data and Policy, Short Course at the EAEPE Pre-Conference for Young Scholars (Warsaw University of Economics, language: English)."
  },
  {
    "objectID": "talks/index.html#section",
    "href": "talks/index.html#section",
    "title": "Talks and presentations",
    "section": "",
    "text": "24.01.2024: Agent-based modelling and complexity economics (Agentenbasiertes Modellieren und Komplexitätsökonomik), Public lecture (University of Siegen, language: German).\n22.11.2024: The Plurality of Pluralist Economics (Die Pluralität der Pluralen Ökonomik), Public lecture (University of Hamburg, language: German).\n22.02.2024: Degrowth: Historical origins, the diversity of the movement and current controversies (Degrowth: Historische Ursprünge, die Vielfalt der Bewegung und aktuelle Kontroversen), Public lecture (Heinrich Böll Foundation, language: German).\n19.01.2024: Pluralism and Complexity: an alternative to the neoclassical equilibrium approach? (Pluralismus und Komplexität: Ein Gegenentwurf zur neoklassischen Gleichgewichtsökonomik?), Public lecture (University of Hamburg, language: German)."
  },
  {
    "objectID": "talks/index.html#section-1",
    "href": "talks/index.html#section-1",
    "title": "Talks and presentations",
    "section": "",
    "text": "07.02.2023: The Emergence of Debt and Secular Stagnation in an Unequal Society, Seminar Talk (Chemnitz University of Technology, language: English).\n14.11.2023: Pluralism and Decoloniality: Friends or Foes?, Public Lecture (University College London, language: English).\n23.01.2023: Agent-based modelling and complexity economics (Agentenbasiertes Modellieren und Komplexitätsökonomik), Public lecture (University of Siegen, language: German)."
  },
  {
    "objectID": "talks/index.html#section-2",
    "href": "talks/index.html#section-2",
    "title": "Talks and presentations",
    "section": "",
    "text": "29.09.2022: Applied Economic Methodology, Keynote given at the Second Philosophy & Economics Conference (University of Vienna, language: English).\n06.09.2022: Automation and Inequalities: The Merits of a Pluralist Research Program in the Context of Automation, Guest Lecture given at the EAEPE Pre-Conference for Young Scholars (Parthenope University of Naples, language: English).\n02.05.2022: Does the truth lie somewhere in between? A pluralist perspective on global inequality (Liegt die Wahrheit irgendwo dazwischen? Eine plurale Perspektive auf globale Ungleichheit), Public lecture (University of Tübingen, language: German).\n19.12.2022: The socioeconomic dimension of sufficiency: possible contributions from pluralist economics (Die sozioökonomischen Dimension von Suffizienz: Mögliche Beiträge der Pluralen Ökonomik), Invited presentation at the symposium on the socio-economic relevance of sufficiency (Europa-University Flensburg, language: German)."
  },
  {
    "objectID": "talks/index.html#section-3",
    "href": "talks/index.html#section-3",
    "title": "Talks and presentations",
    "section": "",
    "text": "29.05.2021: Challenges for pluralism in economics (Herausforderungen einer pluralen Ökonomik), Keynote (Spring school of the German Network for Pluralism in Economics, language: German).\n06.10.2021: Developing System Theory via Agent-Based Modeling, Invited Paper to the International Symposium on Theory Development through Agent-Based Modelling (Hannover, language: English).\n17.11.2021: Complexity Economics: an alternative to the neoclassical equilibrium approach? (Komplexitätsökonomik - Ein Gegenentwurf zur neoklassischen Gleichgewichtsökonomik?), Invited lecture (Zeppelin University, language: German).\n03.12.2021: Complexity Economics - A short introduction (Komplexitätsökonomik - Eine kurze Einführung), Invited lecture (FU Berlin, language: German).\n22.11.2024: The Plurality of Pluralism in Economics (Die Pluralität der Pluralen Ökonomik - Überlegungen zur Zukunft des Pluralismus in der VWL), Keynote at the symposium “The Future of Pluralist Economics” (University of Hamburg, language: German).\n19.10.2021: What is pluralist economics? (Was ist Plurale Ökonomik?), Inaugural speech to the public lecture series on pluralism in economics (Christian-Albrechts-University, language: German). Available on Youtube.\n16.12.2021: Pluralism in Economics & beyond - How a Plurality of Paradigms Helps Understanding Socio-Ecological Challenges, Invited Talk during the Sustainability and Energy Lectures (Europa-University Flensburg, language: English).\n09.06.2021 (together with Birte Strunk): Why we need pluralist economics (Warum braucht es Plurale Ökonomik?), Keynote (University of Vienna, language: German)."
  },
  {
    "objectID": "talks/index.html#section-4",
    "href": "talks/index.html#section-4",
    "title": "Talks and presentations",
    "section": "",
    "text": "02.09.2019: Pluralism, Complexity and the Effective Triangulation of Methods, Keynote (NEEC Summer Schoool on Complexity Economics, Behavioral Economics and Data Science at the University of Bochum, language: English).\n11.-12.09.2019: The Political Economy of Economic Complexity: Models, Data and Policy, Short Course at the EAEPE Pre-Conference for Young Scholars (Warsaw University of Economics, language: English)."
  },
  {
    "objectID": "talks/index.html#section-5",
    "href": "talks/index.html#section-5",
    "title": "Talks and presentations",
    "section": "2023",
    "text": "2023\n\n02.12.2023: Pluralist Economics And Improving The Science Of Economics, in: Jack Roycroft-Sherry’s Science Podcast (by Roycroft-Sherry J.; language: English): Link."
  },
  {
    "objectID": "talks/index.html#section-6",
    "href": "talks/index.html#section-6",
    "title": "Talks and presentations",
    "section": "2022",
    "text": "2022\n\n27.05.2022: Agent-Based Modelling, in: Podcast In der Wirtschaft (by Cremer J., Middelanis M.; language: German): Link."
  },
  {
    "objectID": "teaching/abm-de/Block-1-Loesungen.html",
    "href": "teaching/abm-de/Block-1-Loesungen.html",
    "title": "Mögliche Lösungen zu den Aufgaben aus Block 1",
    "section": "",
    "text": "Aufgabenblock 1: Grundlagen\n1.1. Kreiert eine Liste mit den Zahlen von 1 bis 10. Speichert diese Liste unter dem Namen ‘l_1’ und lasst Python die Liste ausgeben (mit Hilfe der print Funktion).\n\nl_1 = list(range(1,11)) \nprint(l_1)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n\n1.2. Extrahiert das das dritte Element aus dieser Liste, assoziiert es in einer Variable und gebt diese aus.\n\nl_1_e3 = l_1[2]\nprint(l_1_e3)\n\n3\n\n\n1.3. Extrahiert die letzten drei Elemente der Liste und gebt sie aus.\n\nprint(l_1[-3:])\n\n[8, 9, 10]\n\n\n1.4. Ersetzt den ersten Wert der Liste mit der Zahl \\(99.9\\).\n\nl_1[0] = 99.9\n\n1.5. Sortiert die Elemente der Liste in absteigender Reihenfolge. Gebt sie danach über den print Befehl aus.\n\nl_1.sort(reverse=True)\nprint(l_1)\n\n[99.9, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n\n\n1.6. Definiert die folgenden zwei Mengen:\n\\[\\begin{align*}\nm_1 &= \\{1, 4, 23, 95, 12\\}\\\\\nm_2 &= \\{0, 23, 80, 96, 95\\}\\\\\n\\end{align*}\\]\n\nm_1 = {1, 4, 23, 95, 12}\nm_2 = {0, 23, 80, 96, 95}\n\n1.7. Welche Elemente sind in \\(m_1\\), aber nicht in \\(m_2\\)? Speichert diese Elemente in einer Liste und gebt diese aus.\n\nl_diff = list(m_1 - m_2)\nprint(l_diff)\n\n[1, 4, 12]\n\n\n1.8. Speichert die Schnittmenge von \\(m_1\\) und \\(m_2\\) über eine Variable und lasst Python diese Variable ausgeben.\n\nm_intersec = m_1 & m_2\nprint(m_intersec)\n\n{95, 23}\n\n\n1.9. Kreiert ein Wörterbuch mit den folgenden key-value Paaren:\n\n“Hello” and “Hola”\n5 and 120.5\n“bla” and [10, 80]\n\nRuft dann den zu ‘bla’ gehörenden value auf.\n\ndic_1 = {\"Hello\" : \"Hola\", 5 : 120.5, \"bla\" : [10, 80]}\ndic_1[\"bla\"]\n\n[10, 80]\n\n\n\n\nAufgabenblock 2: Funktionen\n2.1.Definiert eine Funktion, die folgende Gleichung berechnet:\n\\[f(x,y) = 10x+(1-y)^2\\]\n\ndef func_expl(x,y):\n    result = 10 * x + (1-y)**2\n    return result\n\nfunc_expl(2,1)\n\n20\n\n\n2.2. Ergänzt die Funktion, sodass sie überprüft ob als Inputs nur ganze Zahlen eingegeben wurden (int). Wenn ein Input keine ganze Zahl ist soll eine Fehlermeldung ausgegeben werden.\n\ndef func_expl(x,y):\n    assert isinstance(x, int), \"Input x kein integer, sonder {}\".format(type(x))\n    assert isinstance(y, int), \"Input y kein integer, sonder {}\".format(type(y))\n    result = 10 * x + (1-y)**2\n    return result\n\nfunc_expl(2,3.0)\n\nAssertionError: Input y kein integer, sonder &lt;class 'float'&gt;\n\n\n\n\nAufgabenblock 3: Loops\n3.1. Erstelle eine Liste mit den Wurzeln der Zahlen zwischen 5 und 15. Stelle die Lösung sowohl als for loop also auch als list comprehension dar.\n\nl_loop = []\nfor i in range(5,16):\n    l_loop.append(i**0.5)\n\nl_comp = [x**0.5 for x in range(5, 16)]\n\nprint(l_loop)\nprint(l_comp)\n\n[2.23606797749979, 2.449489742783178, 2.6457513110645907, 2.8284271247461903, 3.0, 3.1622776601683795, 3.3166247903554, 3.4641016151377544, 3.605551275463989, 3.7416573867739413, 3.872983346207417]\n[2.23606797749979, 2.449489742783178, 2.6457513110645907, 2.8284271247461903, 3.0, 3.1622776601683795, 3.3166247903554, 3.4641016151377544, 3.605551275463989, 3.7416573867739413, 3.872983346207417]\n\n\n3.2. Betrachte den folgenden for loop:\n\nl_1 = [0, 2, \"Land\", \"!\"]\nl_2 = [\"Lame\", \"La\", 1, 3]\nfor i in l_1:\n    print(i * l_2[i], end=\" \")\n\n 2 \n\n\nTypeError: list indices must be integers or slices, not str\n\n\nDieser loop funktioniert so nicht! Schreibe den loop so um, dass er nicht über die einzelnen Elemente von l_1, sondern über die Indices von l_1 iteriert.\nGewünschtes Ergebnis: “LaLa Land!!!\n\nl_1 = [0, 2, \"Land\", \"!\"]\nl_2 = [\"Lame\", \"La\", 1, 3]\nfor i in range(len(l_1)):\n    print(l_1[i] * l_2[i], end=\" \")\n\n LaLa Land !!! \n\n\n3.3. Wie oft muss man \\(1.1\\) quadrieren bis das Ergebnis größer als 10 ist? Verwende einen while loop um diese Frage zu beantworten.\n\ncounter = 0\ncurrent_val = 1.1\nwhile current_val &lt;= 10:\n    current_val = current_val**2\n    counter += 1\nprint(current_val)\nprint(counter)\n\n21.1137767453526\n5\n\n\n3.4. Definiert eine Funktion, welche die folgende Gleichung implementiert:\n\\[f(x) = \\frac{1}{x} + \\frac{1}{x^2}\\]\nNehmt als Startwert \\(x_0=2\\) und berechnet die Zeitreihe, welche durch diese Funktion für 7 Zeitschritte kreiert.\nErläuterung: Ihr könnt die von euch definierte Funktion in einen for loop einbauen, sodass sie in jedem Zeitschritt ihren Output aus dem Zeitschritt davor als Input erhält.\n\ndef func_ex_2(x):\n    result = (1/x) + 1/x**2\n    return result\n\nts = [2]\nfor t in range(7):\n    ts.append(func_ex_2(ts[-1]))\nts\n\n[2,\n 0.75,\n 3.1111111111111107,\n 0.42474489795918374,\n 7.897338780221661,\n 0.1426588076214919,\n 56.14607377836738,\n 0.018127904872052552]\n\n\nHier nur als Illustration wie die Zeitreihe aussieht:\n\nimport matplotlib.pyplot as plt\nplt.plot(range(8), ts)"
  },
  {
    "objectID": "teaching/abm-de/Block-2-Loesungen.html",
    "href": "teaching/abm-de/Block-2-Loesungen.html",
    "title": "Mögliche Lösungen zu den Aufgaben aus Block 2",
    "section": "",
    "text": "Aufgabenblock 1: Die Studentenklasse\nIn der Videolecture haben wir die folgende Klasse Student entwickelt:\n\nclass Student:\n    \"\"\"\n    This is a class called student.\n    \"\"\"\n    profession = \"student\"\n    \n    def __init__(self, name, affiliation):\n        self.name = name\n        self.affiliation = affiliation\n        self.beers = 0\n        self.credits = 0\n        self.friends = set()\n        \n    def __repr__(self):\n        return self.name\n    \n    def drink(self, beers):\n        self.beers += beers\n        return beers*[\"Cheers!\"]\n    \n    def study(self, cp_earned):\n        self.credits += cp_earned\n    \n    def make_friend(self, new_friend):\n        assert isinstance(new_friend, Student), \"A student can only befriend other students!\"\n        self.friends.add(new_friend)\n    \n    def drink_with_friends(self, beers):\n        for f in self.friends:\n            f.drink(beers)\n            self.drink(beers)\n\nAufgabe 1.1: Ergänze die __repr__ Funktion des Studenten, sodass sie nicht nur seinen Namen, sondern auch die Anzahl der Credits und der Biere augegeben werden. Wenn die Instanz des Studierenden aufgerufen wird, soll die Ausgabe in etwa folgendermaßen ausseßen (vorausgesetzt, die Studenting heißt Claire, hat 5 Biere getrunken, und 10 credits erhalten):\n\nprint(\"Claire (5 Biere und 10 Credits)\")\n\nClaire (5 Biere und 10 Credits)\n\n\nHinweis: Denkt daran, dass ihr einzelne Strings mit dem Additionsoperator + miteinender verbinden könnt:\n\n\"Hallo\" + \" und \" + \"Tschuess!\"\n\n'Hallo und Tschuess!'\n\n\nHinweis 2: Das funktioniert nur mit strings! Zahlen müssen vorher in strings umgewandelt werden (siehe Funktion str).\n\nclass Student:\n    \"\"\"\n    This is a class called student.\n    \"\"\"\n    profession = \"student\"\n    \n    def __init__(self, name, affiliation):\n        self.name = name\n        self.affiliation = affiliation\n        self.beers = 0\n        self.credits = 0\n        self.friends = set()\n        \n    def __repr__(self):\n        return_val = self.name + \" (\" + str(self.beers) + \" Biere und \" + str(self.credits) + \" Credits)\"\n        return return_val\n    \n    def drink(self, beers):\n        self.beers += beers\n        return beers*[\"Cheers!\"]\n    \n    def study(self, cp_earned):\n        self.credits += cp_earned\n    \n    def make_friend(self, new_friend):\n        assert isinstance(new_friend, Student), \"A student can only befriend other students!\"\n        self.friends.add(new_friend)\n    \n    def drink_with_friends(self, beers):\n        for f in self.friends:\n            f.drink(beers)\n            self.drink(beers)\nclaire = Student(\"Claire\", \"Uni Erfurt\")\nclaire\n\nClaire (0 Biere und 0 Credits)\n\n\nAufgabe 1.2: Ergänzt die __init__ Funktion, sodass jede Instanz des Studenten auch ein Instanzenattribut title hat. Dieses soll bei Instanziierung eines Studenten zunächst den Wert 'nichts' haben.\n\nclass Student:\n    \"\"\"\n    This is a class called student.\n    \"\"\"\n    profession = \"student\"\n    \n    def __init__(self, name, affiliation):\n        self.name = name\n        self.affiliation = affiliation\n        self.beers = 0\n        self.credits = 0\n        self.friends = set()\n        self.title = \"nichts\"\n        \n    def __repr__(self):\n        return_val = self.name + \" (\" + str(self.beers) + \" Biere und \" + str(self.credits) + \" Credits)\"\n        return return_val\n    \n    def drink(self, beers):\n        self.beers += beers\n        return beers*[\"Cheers!\"]\n    \n    def study(self, cp_earned):\n        self.credits += cp_earned\n    \n    def make_friend(self, new_friend):\n        assert isinstance(new_friend, Student), \"A student can only befriend other students!\"\n        self.friends.add(new_friend)\n    \n    def drink_with_friends(self, beers):\n        for f in self.friends:\n            f.drink(beers)\n            self.drink(beers)\nclaire = Student(\"Claire\", \"Uni Erfurt\")\nclaire.title\n\n'nichts'\n\n\nAufgabe 1.3: Ergänze die Klasse Student um eine neue Instanzenfunktion namens graduate. Diese Funktion soll überprüfen ob der Studierende mindestens 180 credits und 90 Biere hat.\nFalls ja, soll das Attribut title auf den String 'BA' geändert werden. Zudem soll dann die Funktion drink_with_friends mit 10 Bieren aufgerufen werden und eine Meldung (durch print) ausgegeben werden, dass der Student jetzt graduiert ist.\nFalls nein, soll nur eine Meldung (durch print ausgegeben werden), dass der Student noch nicht graduieren kann.\nHinweis: Mehrere Abfragen in if/else statements können durch das and Keyword durchgeführt werden:\n\n(2&lt;3) and (4&gt;2)\n\nTrue\n\n\n\n(2&lt;3) and (2&gt;2)\n\nFalse\n\n\n\nclass Student:\n    \"\"\"\n    This is a class called student.\n    \"\"\"\n    profession = \"student\"\n    \n    def __init__(self, name, affiliation):\n        self.name = name\n        self.affiliation = affiliation\n        self.beers = 0\n        self.credits = 0\n        self.friends = set()\n        self.title = \"nichts\"\n        \n    def __repr__(self):\n        return_val = self.name + \" (\" + str(self.beers) + \" Biere und \" + str(self.credits) + \" Credits)\"\n        return return_val\n    \n    def drink(self, beers):\n        self.beers += beers\n        return beers*[\"Cheers!\"]\n    \n    def study(self, cp_earned):\n        self.credits += cp_earned\n    \n    def make_friend(self, new_friend):\n        assert isinstance(new_friend, Student), \"A student can only befriend other students!\"\n        self.friends.add(new_friend)\n    \n    def drink_with_friends(self, beers):\n        for f in self.friends:\n            f.drink(beers)\n            self.drink(beers)\n            \n    def graduate(self):\n        if (self.credits&gt;=180) and (self.beers&gt;=90):\n            self.title = \"BA\"\n            self.drink_with_friends(10)\n            print(\"Hurra! Graduiert!\")\n        else:\n            print(\"Oh weh, kann noch nicht graduieren...\")\n            \nclaire = Student(\"Claire\", \"Uni Erfurt\")\nclaire.graduate()\n\nOh weh, kann noch nicht graduieren...\n\n\nAufgabe 1.4: Erstellt eine Instanz der Klasse Student und lasst sie so lange trinken und lernen, bis sie graduieren kann. Dann lasst sie graduieren.\n\nclaire = Student(\"Claire\", \"Uni Erfurt\")\nclaire.study(180)\nclaire.drink(90)\nclaire.graduate()\n\nHurra! Graduiert!\n\n\nAufgabe 1.5: Schreibt eine Klasse FlunkyBall. Diese Klasse soll zwei Teams erstellen, die jeweils aus einer gleichen Anzahl von Studenten bestehen sollen. Die Anzahl der Studenten pro Team soll als Argument der __init__ Funktion gegeben werden.\nDann soll die Klasse über eine Funktion play verfügen: diese Funktion nimmt ein Argument an. Dieses Argument spezifiziert, welches der Teams verliert. Alle Mitglieder des Verliererteams müssen nun ein Bier trinken.\nHinweis 1: Hier müssen wahrscheinlich if/else Befehle verwendet werden.\nHinweis 2: Ihr könnt euch hier ein wenig an der Klasse StuRa orientieren, die wir in den Video Lectures erstellt haben:\n\nclass StuRa:\n    \"\"\"\n    A class for StuRas\n    \"\"\"\n    function = \"Organisation der Studis\"\n    \n    def __init__(self, members):\n        assert isinstance(members, set), \"Members must given as set!\"\n        for m in members:\n            assert isinstance(m, Student), \"Members as such must be students!\"\n        self.members = members\n    \n    def befriend_members(self):\n        \"\"\"\n        Befriends all members.\n        \"\"\"\n        for m in self.members:\n            for n in self.members:\n                if m is not n:\n                    m.make_friend(n)\n    \n    def hard_work(self, amount_work):\n        for m in self.members:\n            print(m, \"works hard!\")\n            m.drink(amount_work)\n\nHinweis 3: Wir haben in den Video lectures gesehen wie man einfach eine größere Menge Studenten erstellt:\n\nn_students = 10\nlist_of_students = {Student(\"student_\" + str(x), \"Uni Erfurt\") for x in range(n_students)}\n\n\nclass FlunkyBall:\n    def __init__(self, n_players):\n        self.team_1 = {Student(\"student_\" + str(x), \"Uni Erfurt\") for x in range(int(n_players/2))}\n        self.team_2 = {Student(\"student_\" + str(x), \"Uni Erfurt\") for x in range(int(n_players/2), n_players)}\n        \n    def play(self, winner):\n        assert (winner==1) or (winner==2), \"Must specify team 1 or 2!\"\n        if winner == 1:\n            for m in self.team_2:\n                m.drink(1)\n        else:\n            for m in self.team_1:\n                m.dring(1)\n\nfunny_flunky = FlunkyBall(10)\nfunny_flunky.play(1)\n\n\n\nAufgabenblock 2: Das Solow Wachstumsmodell\nIn dieser Aufgabe sollt ihr eine Version von Solow’s Wachstumsmodell erstellen. Klingt anspruchsvoll, aber mit ein paar Hinweisen könnt könnt ihr das schon!\nErster Schritt: Eine Klasse für die Ökonomie!: Als erster Schritt müsst ihr eine Klasse Economy erstellen.\nDiese Klasse soll drei Instanzeneigenschaften haben: capital, labor, und bip. Diese Klasseneigenschaften sollen jeweils aus einer Liste bestehen. Deren erstes Element soll für capital und labor als Argument an die __init__ Funktion übergeben werden. bip soll als leere Liste instantiiert werden.\nAls Starthilfe hier schon einmal folgendes Grundgerüst, das ihr weiterverwenden könnt:\n\nclass Economy:\n    \"\"\"\n    An economy.\n    \"\"\"\n    def __init__(self, ):\n        self.capital = capital\n        self.labor\n        self.\n\nDie Lösung wäre:\n\nclass Economy:\n    \"\"\"\n    An economy.\n    \"\"\"\n    def __init__(self, ):\n        self.capital = [capital]\n        self.labor = [labor]\n        self.bip = []\n\nZweiter Schritt: Eine Funktion für das BIP: Im nächsten Schritt müsst ihr eine Klassenfunktion schreiben, die für die aktuellen Werte von capital und labor den entsprechenden Wert für BIP berechnet.\nDas Solow Wachstumsmodell verwendet hierfür ein Cobb-Douglas Produktionsfunktion:\n\\[Y_t = K_t^\\alpha L_t^{1-\\alpha}\\]\nDas bedeutet: der Wert für das BIP (\\(Y\\) in der Gleichung) zum Zeitpunkt \\(t\\) beträgt der aktuelle Kapitelstock exponiert mit dem Wert \\(\\alpha\\) multipliziert mit der Arbeitskraft der Ökonomie (\\(L\\) in der Gleichung), exponiert mit dem Wert (\\(1-\\alpha\\)).\nAußerhalb einer Klasse können wir diese Funktion folgendermaßen in Python implementieren:\n\ndef cobb_douglas(capital, labor, alpha):\n    bip = capital**alpha * labor**(1-alpha)\n    return bip\n\nImplementiert diese Funktion als Klassenfunktion in der Klasse Economy. Vergesst nicht, dass self Argument hinzuzufügen!\n\nclass Economy:\n    \"\"\"\n    An economy.\n    \"\"\"\n    def __init__(self, capital, labor ):\n        self.capital = [capital]\n        self.labor = [labor]\n        self.bip = []\n    \n    def cobb_douglas(self, capital, labor, alpha):\n        bip = capital**alpha * labor**(1-alpha)\n        return bip\n\nexpl_econ = Economy(5, 10)\n\nDritter Schritt: Anpassung der Basisklasse: Wir sind schon bald fertig! Ergänzt nun die __init__ Funktion eurer Klasse Economy sodass sie ein weiteres Argument annimmt: alpha. Dieses soll als Instanzenattribut gespeichert werden, genauso wie capital, labor und bip, nur nicht als liste, sondern als float.\nAuch könnt ihr nun die Instanzenfunktion cobb_douglas anpassen: sie soll nun nicht mehr alpha als Argument nehmen. Vielmehr kann sie alpha direkt als Instanzenattribut ansprechen.\nDas ist ähnlich als ob bei der Funktion oben alpha vorher außerhalb der Funktion definiert worden wäre. Ihr müsst diese Logik nur an euren Klassenkontext angepasst werden (denkt an die Rolle von self):\n\nalpha = 0.5\ndef cobb_douglas(capital, labor):\n    bip = capital**alpha * labor**(1-alpha)\n    return bip\ncobb_douglas(10, 20)\n\n14.142135623730953\n\n\nHinweis:\n\nclass Economy:\n    \"\"\"\n    An economy.\n    \"\"\"\n    def __init__(self, alpha, ):\n        self.alpha = \n        self.capital = capital\n        self.labor\n        self.\n\n\nclass Economy:\n    \"\"\"\n    An economy.\n    \"\"\"\n    def __init__(self, alpha, capital, labor):\n        self.capital = [capital]\n        self.labor = [labor]\n        self.bip = []\n        self.alpha = alpha\n    \n    def cobb_douglas(self, capital, labor):\n        bip = capital**self.alpha * labor**(1-self.alpha)\n        return bip\n\nexpl_econ = Economy(0.5, 10, 20)\n\nVierter Schritt: Ersten BIP Wert berechnen Ihr müsst nun ein letztes Mal die __init__ Funktion anpassen: sie soll den ersten Wert für self.bip mit der Funktion cobb_douglas festlegen.\nHinweis:\n\nclass Economy:\n    \"\"\"\n    An economy.\n    \"\"\"\n    def __init__(self, alpha, ):\n        self.alpha = \n        self.capital = capital\n        self.labor\n        self.bip = []\n        self.bip.append(self.cobb_douglas(self.capital[-1], self. ))\n\n\nclass Economy:\n    \"\"\"\n    An economy.\n    \"\"\"\n    def __init__(self, alpha, capital, labor):\n        self.alpha = alpha\n        self.capital = [capital]\n        self.labor = [labor]\n        self.bip = []\n        self.bip.append(self.cobb_douglas(self.capital[-1], self.labor[-1]))\n\n    \n    def cobb_douglas(self, capital, labor):\n        bip = capital**self.alpha * labor**(1-self.alpha)\n        return bip\n\nexpl_econ = Economy(0.5, 10, 20)\nexpl_econ.bip\n\n[14.142135623730953]\n\n\nFünfter Schritt: Die Zeitschritte: Ihr müsst nun eine weitere Instanzenfunktion hinzufügen: timestep. Diese Funktion nimmt als Input die aktuellen Werte von capital, labor und bip und berechnet den Wert für den nächsten Zeitschritt.\nDie Veränderungen von capital und labor ergeben sich aus dem Investment in neues Kapital, der Kapitalabnutzung und dem Bevölkerungswachstum. Diese Veränderungen lassen sich durch folgende beiden Funktionen berechnen, die voraussetzen, dass \\(5\\%\\) des BIP in Kapital investiert wird, \\(6\\%\\) des aktuellen Kapitalstocks abgenutzt werden, und die Bevölkerung mit \\(3\\%\\) pro Zeitschritt wächst.\n\nclass Economy:\n    def change_capital(self):\n        change_of_capital = self.bip[-1]*0.05 - self.capital[-1]*0.06\n        return change_of_capital\n    \n    def change_labor(self):\n        change_of_labor = self.labor[-1]*0.03\n        return change_of_labor\n\nHinweis: Die [-1] Notation ruft das letzte Element einer Liste auf:\n\nl_1 = [1,2,3,4]\nl_1[-1]\n\n4\n\n\nDie Funktion timestep soll also alle drei Update Funktionen aufrufen, die neuen Werte berechnen, und an die Listen für capital, labor und bip anhängen (mit der append Methode).\nFolgender Hinweis ist vielleicht hilfreich:\n\nclass Economy:\n    def change_capital(self):\n        change_of_capital = self.bip[-1]*0.05 - self.capital[-1]*0.06\n        return change_of_capital\n    \n    def timestep(self):\n        capital_change = self.change_capital()\n        capital_new = self.capital[-1] + capital_change capital\n        self.capital.append(capital_new)\n        # similar operations for labor and bip\n\n\nclass Economy:\n    \"\"\"\n    An economy.\n    \"\"\"\n    def __init__(self, alpha, capital, labor):\n        self.alpha = alpha\n        self.capital = [capital]\n        self.labor = [labor]\n        self.bip = []\n    \n    def cobb_douglas(self, capital, labor):\n        bip = capital**self.alpha * labor**(1-self.alpha)\n        return bip\n    \n    def change_capital(self):\n        change_of_capital = self.bip[-1]*0.05 - self.capital[-1]*0.06\n        return change_of_capital\n    \n    def change_labor(self):\n        change_of_labor = self.labor[-1]*0.03\n        return change_of_labor\n    \n    def timestep(self):\n        capital_change = self.change_capital()\n        capital_new = self.capital[-1] + capital_change\n        self.capital.append(capital_new)\n        \n        labor_change = self.change_labor()\n        labor_new = self.labor[-1] + labor_change\n        self.labor.append(labor_new)\n        \n        bip_new = self.cobb_douglas(self.capital[-1], self.labor[-1])\n        self.bip.append(bip_new)\n\nexpl_econ = Economy(0.25, 5, 10)\nexpl_econ\n\n&lt;__main__.Economy at 0x113b489d0&gt;\n\n\nSechster Schritt: Die run Funktion: Das ist der letzte Schritt. Definiert eine Funktion run, die als Argument die Anzahl der Zeitschritte nimmt, und dann capital, labor und bip für die Anzahl der Zeitschritte neu berechnet. In jedem Zeitschritt soll die Funktion timestep aufgerufgen werden.\nHinweis:\n\nclass Economy:\n    \n    def run(self, ):\n        for t in range( ):\n            print(t)\n            self. \n\n\nclass Economy:\n    \"\"\"\n    An economy.\n    \"\"\"\n    def __init__(self, alpha, capital, labor):\n        self.alpha = alpha\n        self.capital = [capital]\n        self.labor = [labor]\n        self.bip = []\n        self.bip.append(self.cobb_douglas(self.capital[-1], self.labor[-1]))\n    \n    def cobb_douglas(self, capital, labor):\n        bip = capital**self.alpha * labor**(1-self.alpha)\n        return bip\n    \n    def change_capital(self):\n        change_of_capital = self.bip[-1]*0.05 - self.capital[-1]*0.06\n        return change_of_capital\n    \n    def change_labor(self):\n        change_of_labor = self.labor[-1]*0.03\n        return change_of_labor\n    \n    def timestep(self):\n        capital_change = self.change_capital()\n        capital_new = self.capital[-1] + capital_change\n        self.capital.append(capital_new)\n        \n        labor_change = self.change_labor()\n        labor_new = self.labor[-1] + labor_change\n        self.labor.append(labor_new)\n        \n        bip_new = self.cobb_douglas(self.capital[-1], self.labor[-1])\n        self.bip.append(bip_new)\n    \n    def run(self, t_steps):\n        for t in range(t_steps):\n            print(t)\n            self.timestep()\n\nSiebter Schritt Erstellt eine Instanz eurer Ökonomie, lasst das Modell für 10 Zeitschritte laufen, und lasst euch die finalen Werte für capital, labor und bip ausgeben. Ihr könnt hier folgendes Muster verwenden:\n\nexpl_econ = Economy(0.4, 5, )\nexpl_econ.run( )\n\n\nexpl_econ = Economy(0.4, 5, 8)\nexpl_econ.run(10)\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nHier sind die relevanten Statusvariablen:\n\nexpl_econ.labor\n\n[8,\n 8.24,\n 8.4872,\n 8.741816,\n 9.00407048,\n 9.274192594399999,\n 9.552418372232,\n 9.83899092339896,\n 10.13416065110093,\n 10.438185470633957,\n 10.751331034752976]\n\n\n\nexpl_econ.capital\n\n[5,\n 5.031445401733999,\n 5.06778191105444,\n 5.108982601976881,\n 5.155029407627849,\n 5.205912785920756,\n 5.261631412835216,\n 5.322191901872839,\n 5.3876085483457805,\n 5.457903097233226,\n 5.533104533415775]\n\n\n\nexpl_econ.bip\n\n[6.628908034679974,\n 6.764464668489624,\n 6.9053521117141425,\n 7.0517152353916135,\n 7.203702855011553,\n 7.361467881394116,\n 7.525167476154716,\n 7.694963211706246,\n 7.871021235763835,\n 8.053512440330865,\n 8.242612635159615]\n\n\nWir können das auch visualisieren (mehr dazu aber in einer späteren Session):\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfig, axes = plt.subplots(3,1)\n\naxes[0].plot(np.linspace(0, 10, 11), expl_econ.labor)\naxes[0].title.set_text(\"Labor dynamics\")\naxes[1].plot(np.linspace(0, 10, 11), expl_econ.capital)\naxes[1].title.set_text(\"Capital dynamics\")\naxes[2].plot(np.linspace(0, 10, 11), expl_econ.bip)\naxes[2].title.set_text(\"BIP dynamics\")\nfig.tight_layout()"
  },
  {
    "objectID": "teaching/abm-de/Block-3-Loesungen.html",
    "href": "teaching/abm-de/Block-3-Loesungen.html",
    "title": "Mögliche Lösungen zu den Aufgaben aus Block 3",
    "section": "",
    "text": "Der zentrale Grenzwertsatz\n\nVisualisiert die Funktion des zentralen Grenzwertsatzes anhand einer beliebigen Verteilung.\n\nHinweis: Der zentrale Grenzwertsatz besagt, dass die Mittelwerte aus vielen Stichproben, die unabhängig voneinander gezogen werden, normalverteilt sind, unabhängig von der zugrundeliegenden Verteilung. Um das zu zeigen, müsst ihr viele Stichproben einer Verteilung ziehen (nicht der Normalverteilung), jedes Mal den Mittelwert berechnen, und dann ein Histogramm dieser Mittelwerte erstellen. Je mehr Stichproben ihr berücksichtigt, desto ähnlicher sollte die Verteilung einer Normalverteilung werden.\nSolution: For the solution I use the Poisson distribution with \\(\\lambda=1\\). As you can verify from the following plot it does not look like a normal distribution at all:\n\\[x^2+y3+\\frac{2}{3}\\]\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom scipy import stats\npmf_poisson = stats.poisson.pmf(np.linspace(0,20, 21, dtype=int), 1.0)  \npdf_normal = stats.norm.pdf(np.linspace(-5,5, 200))\n\n\nfig, ax = plt.subplots(2,1)\nax[0].spines[\"top\"].set_visible(False) # Remove plot frame line on the top \nax[0].spines[\"right\"].set_visible(False) # Remove plot frame line on the right\nax[0].get_xaxis().tick_bottom()  # Remove ticks on the bottom\nax[0].get_yaxis().tick_left()  # Remove the ticks on the left\nax[0].plot(np.linspace(0,20, 21), pmf_poisson, color=\"#801a00\", marker=\"o\")\nax[0].set_title(\"PMF of the poisson distribution with lambda=1\")\n\nax[1].spines[\"top\"].set_visible(False) # Remove plot frame line on the top \nax[1].spines[\"right\"].set_visible(False) # Remove plot frame line on the right\nax[1].get_xaxis().tick_bottom()  # Remove ticks on the bottom\nax[1].get_yaxis().tick_left()  # Remove the ticks on the left\nax[1].plot(np.linspace(-5, 5, 200), pdf_normal, color=\"#801a00\")\nax[1].set_title(\"PDF of the standard normal distribution\")\nfig.tight_layout()\n\n\n\n\n\nCreate many samples from the Poisson distribution and calculate the mean\n\n\nsample_size = 100\n\nn = 10\npoisson_mean_n10 = [np.mean(np.random.poisson(lam=1.0, size=sample_size)) for i in range(n)]\nn = 1000\npoisson_mean_n1000 = [np.mean(np.random.poisson(lam=1.0, size=sample_size)) for i in range(n)]\nn = 5000\npoisson_mean_n5000 = [np.mean(np.random.poisson(lam=1.0, size=sample_size)) for i in range(n)]\nn = 50000\npoisson_mean_n50000 = [np.mean(np.random.poisson(lam=1.0, size=sample_size)) for i in range(n)]\n\n\nFit normals to the samples\n\n\nn10_parameters = stats.norm.fit(poisson_mean_n10)\nn10_pdf = stats.norm.pdf(np.linspace(0,2, 200), loc=n10_parameters[0], scale=n10_parameters[1])\n\nn1000_parameters = stats.norm.fit(poisson_mean_n1000)\nn1000_pdf = stats.norm.pdf(np.linspace(0,2, 200), loc=n1000_parameters[0], scale=n1000_parameters[1])\n\nn5000_parameters = stats.norm.fit(poisson_mean_n5000)\nn5000_pdf = stats.norm.pdf(np.linspace(0,2, 200), loc=n5000_parameters[0], scale=n5000_parameters[1])\n\nn50000_parameters = stats.norm.fit(poisson_mean_n50000)\nn50000_pdf = stats.norm.pdf(np.linspace(0,2, 200), loc=n50000_parameters[0], scale=n50000_parameters[1])\n\n\nVisualize the results\n\n\nfig, axes = plt.subplots(2,2, figsize=(12, 9))\n\naxes[0,0].spines[\"top\"].set_visible(False) # Remove plot frame line on the top \naxes[0,0].spines[\"right\"].set_visible(False) # Remove plot frame line on the right\naxes[0,0].get_xaxis().tick_bottom()  # Remove ticks on the bottom\naxes[0,0].get_yaxis().tick_left()  # Remove the ticks on the left\naxes[0,0].hist(poisson_mean_n10, color=\"#3F5D7D\", bins=\"auto\", density=True)\naxes[0,0].set_title(\"10 Samples\")\naxes[0,0].plot(np.linspace(0, 2, 200), n10_pdf, color=\"#801a00\")\n\naxes[0,1].spines[\"top\"].set_visible(False) # Remove plot frame line on the top \naxes[0,1].spines[\"right\"].set_visible(False) # Remove plot frame line on the right\naxes[0,1].get_xaxis().tick_bottom()  # Remove ticks on the bottom\naxes[0,1].get_yaxis().tick_left()  # Remove the ticks on the left\naxes[0,1].hist(poisson_mean_n1000, color=\"#3F5D7D\", bins=\"auto\", density=True)\naxes[0,1].set_title(\"1000 Samples\")\naxes[0,1].plot(np.linspace(0, 2, 200), n1000_pdf, color=\"#801a00\")\n\naxes[1,0].spines[\"top\"].set_visible(False) # Remove plot frame line on the top \naxes[1,0].spines[\"right\"].set_visible(False) # Remove plot frame line on the right\naxes[1,0].get_xaxis().tick_bottom()  # Remove ticks on the bottom\naxes[1,0].get_yaxis().tick_left()  # Remove the ticks on the left\naxes[1,0].hist(poisson_mean_n5000, color=\"#3F5D7D\", bins=\"auto\", density=True)\naxes[1,0].set_title(\"5000 Samples\")\naxes[1,0].plot(np.linspace(0, 2, 200), n5000_pdf, color=\"#801a00\")\n\naxes[1,1].spines[\"top\"].set_visible(False) # Remove plot frame line on the top \naxes[1,1].spines[\"right\"].set_visible(False) # Remove plot frame line on the right\naxes[1,1].get_xaxis().tick_bottom()  # Remove ticks on the bottom\naxes[1,1].get_yaxis().tick_left()  # Remove the ticks on the left\naxes[1,1].hist(poisson_mean_n50000, color=\"#3F5D7D\", bins=95, density=True)\naxes[1,1].set_title(\"50000 Samples\")\naxes[1,1].plot(np.linspace(0, 2, 200), n50000_pdf, color=\"#801a00\")\nfig.tight_layout()\n\n\n\n\n\n\nDas Gesetz der großen Zahl\n\nVisualisiert die Implikationen vom Gesetz der großen Zahl.\n\nHinweis: Das Gesetz der großen Zahl besagt, dass bei wachsender Stichprobengröße der Mittelwert (und oft weitere Momente) der Stichprobe zum wahren Mittelwert (bzw. den wahren Momenten) der zugrundeliegenden Verteilung konvergiert. Um das zu zeigen könnt ihr vier verschiedene Histogramme darstellen, die alle auf Basis unterschiedlich großer Stichproben erstellt wurden. Im Skript findet sich eine ähnliche Anwendung.\nLösung: Hier wird das Gesetz anhand der Normalverteilung illustriert. Wir setzen einen Mittelwert von 1.0 selbst fest.\n\nsample_sizes = np.linspace(10, 10000, 10, dtype=int)\nsample_means = [np.mean(np.random.normal(loc=1.0, size=x)) for x in sample_sizes]\n\n\nfig, ax = plt.subplots()\nax.plot(sample_sizes, sample_means)\nax.plot(sample_sizes, [1.0]*len(sample_sizes))\nfig.tight_layout()\n\n\n\n\nMan beachte jedoch, dass dieses Gesetz nicht für alle Verteilungen gilt!\n\n\nZusatzaufgabe: Anwendung & Verbindung mit OOP\nProgrammiert ein ABM, in dem zwei Spieler miteinander folgendes Spiel spielen: sie werfen eine Münze und bei Kopf gewinnt der erste Spieler (i.e. er oder sie bekommt einen Punkt), bei Zahl gewinnt der zweite Spieler (i.e. er oder sie bekommt einen Punkt).\nHierzu benötigt ihr zwei Klassen:\n\nEine Klasse Spieler. Diese Klasse sollte als Instanzeneigenschaft die Menge an bisher gesammelten Punkten haben (sollte mit 0 anfangen), sowie Information darüber ob der Spieler bei Kopf oder Zahl gewinnt (sollte über __init__ festgelegt werden). Außerdem sollte sie eine Instanzenfunktion haben, die als Argument den Ausgang eines Münzwurfs nimmt und die gesammelten Punkte entsprechend anpasst.\nEine Klasse Spiel, die als Instanzeneigenschaft die Liste der beiden Spieler hat und eine Instanzenfunktion besitzt, die einen Münzwurf simuliert.\n\nLasst die Spieler das Spiel 100 Mal spielen.\n\nclass Spieler:\n    def __init__(self, gewinnerseite):\n        self.points = 0\n        self.win_side = gewinnerseite\n        \n    def get_points(self, side):\n        if side == self.win_side:\n            self.points += 1\n\nclass Spiel:\n    def __init__(self):\n        self.players = [Spieler(\"Kopf\"), Spieler(\"Zahl\")]\n        \n    def throw_coin(self):\n        if np.random.randint(0, 2) == 0:\n            result = \"Kopf\"\n        else:\n            result = \"Zahl\"\n        for a in self.players:\n            a.get_points(result)\n\nspiel = Spiel()\nfor i in range(1000):\n    spiel.throw_coin()\n\nfig, ax = plt.subplots()\nax.bar(x = [\"Spieler 1\",\"Spieler 2\"], height=[spiel.players[0].points, spiel.players[1].points])\nax.set_title(\"Punkte der Spieler nach 1000 Würfen\")\n\nText(0.5, 1.0, 'Punkte der Spieler nach 1000 Würfen')"
  },
  {
    "objectID": "teaching/abm-de/Block-4-Loesungen.html",
    "href": "teaching/abm-de/Block-4-Loesungen.html",
    "title": "Mögliche Lösungen zu den Aufgaben aus Block 4",
    "section": "",
    "text": "Beide Aufgaben beziehen sich auf die Implementierung des Arthur Modells, das in den Video Lectures entwickelt wurde. Ihr könnt entweder eure eigene, oder die von mir vorbereitete Implementierung als Ausgangspunkt verwenden.\nIn den Hausaufgaben geht es vor allem darum, die Implementierung nachzuvollziehen. Dann sollt ihr die folgenden beiden Erweiterungen implementieren und die Effekte entsprechend visualisieren.\nDazu könnt ihr entweder neue subplots zu der vorgeschlagenen Visualisierung hinzufügen, eine neue Form der Visualisierung erstellen, oder einen der alten Fälle in der alten Visualisierung ersetzen."
  },
  {
    "objectID": "teaching/abm-de/Block-4-Loesungen.html#hinweise-zur-lösung",
    "href": "teaching/abm-de/Block-4-Loesungen.html#hinweise-zur-lösung",
    "title": "Mögliche Lösungen zu den Aufgaben aus Block 4",
    "section": "Hinweise zur Lösung",
    "text": "Hinweise zur Lösung\nDas Modell muss hierfür nicht fundamental geändert werden. Die folgenden Änderungen müssen durchgeführt werden:\n\nIn der __init__ Funktion der Klasse Model muss die Möglichkeit zugelassen werden, dass die Nachbarschaft random spezifiziert wird.\n\nclass Model:\n    \"\"\"...   \n    \"\"\"\n     \n    def __init__(self, n_agents, neighborhood_str, identifier):\n        \"\"\"...\n        \"\"\"\n        # No change\n        assert neighborhood_str in [\"ring\", \"full\", \"random\"], \"No correct neighborhood \\\n        structure specified. Currently allowed: 'full' or 'ring' or 'random', but not {}\"\\\n        .format(neighborhood_str)\n        self.neighborhood = neighborhood_str\n\nDie Funktion create_neighborhood_structure muss ergänzt werden. Folgender Code wäre möglich:\n\nclass Model:\n    \"\"\"...\n    \"\"\"\n     \n    def __init__(self, n_agents, neighborhood_str, identifier):\n        \"\"\"...\n        \"\"\"\n    # No change\n        \n    def create_neighborhood_structure(self):\n        \"\"\"...\n        \"\"\"\n        if self.neighborhood == \"ring\":\n            print(\"Creating ring neighborhood...\", end=\"\")\n            # No change\n                \n        elif self.neighborhood == \"full\":\n            print(\"Creating full neighborhood...\", end=\"\")\n            # No change\n            \n        elif self.neighborhood == \"random\":\n            print(\"Creating random neighborhood...\", end=\"\")\n            for a in range(len(self.agentlist)):\n                neighborhood_choice_list = self.agentlist.remove(self.agentlist[a])\n                self.agentlist[a].add_neighbors(np.random.choice(self.agentlist, size=4, replace=False))\nHierbei sind zwei Punkte zu beachten: * Wir müssen verhindern, dass der Agent sich selbst zu seiner Nachbarschaft hinzufügt indem man einer Variable neighborhood_choice_list erstellt, die alle Agenten außer dem Agenten selbst enthält * Wir müssen verhindern, dass ein Agent doppelt für die Nachbarschaft gezogen wird, das heißt np.random.choice muss mit dem Argumten replace=False aufgerufen werden.\n\nZuletzt muss noch die Klasse Main angepasst werden, indem auch Modellinstanzen mit einer zufälligen Nachbarschaft erstellt werden. Entsprechend muss das auch im neighborhood_dict berücksichtigt werden:\n\nclass Main:\n    \"\"\"...\n    \"\"\"\n    \n    def __init__(self, nb_agents, neighborhood_dict, outcome_filename):\n        # No change\n        self.nb_simulations = (self.neighborhood_dict[\"full\"] + \n                               self.neighborhood_dict[\"ring\"] + \n                               self.neighborhood_dict[\"random\"])\n        # No change\n        for i in range(self.neighborhood_dict[\"random\"]):\n            current_model = model.Model(self.nb_agents, \"random\", self.current_id)\n        # No change\n\nneigh_dict = {\"full\" : 20, # Nb of simulation runs with complete neigborhood \n              \"ring\" : 20, # Nb of simulation runs with ring neigborhood \n              \"random\" : 20}"
  },
  {
    "objectID": "teaching/abm-de/Block-4-Loesungen.html#hinweise-zur-lösung-1",
    "href": "teaching/abm-de/Block-4-Loesungen.html#hinweise-zur-lösung-1",
    "title": "Mögliche Lösungen zu den Aufgaben aus Block 4",
    "section": "Hinweise zur Lösung",
    "text": "Hinweise zur Lösung\nHier muss zunächst eine Änderung in der Klasse Agent vorgenommen werden: wir müssen ein zusätzliches Argument in der __init__ Funktion hinzufügen, das spezifiziert ob der Agent entweder Technologie 0 oder Technologie ein setzt.\nEntsprechend muss dann die Funktion tec_choice leicht angepasst werden.\nclass Agent():\n    \"\"\"...\n    \"\"\"\n    \n    def __init__(self, pref_tech):\n        self.neighborhood = set()       \n        self.tech_chosen = None\n        if pref_tech == 0:\n            self.pref_tech_0 = 0.25\n        else:\n            self.pref_tech_0 = 0.75\n    \n    # No change\n    \n    def tec_choice(self):\n        \"\"\"...\n        \"\"\"\n        # No change\n        \n        # make technology choice \n        if len(techs_neighborhood) &gt; 0:        \n            if self.pref_tech_0 &lt; share_t1:\n                self.tech_chosen = 1\n            else:\n                self.tech_chosen = 0\n        else:\n            if self.pref_tech_0 &lt; 0.5 :\n                self.tech_chosen = 1\n            else:\n                self.tech_chosen = 0\nZuletzt muss dann noch sichergestellt werden, dass 50% der Agenten mit Präferenz für Tech 0 und 50% mit Präferenz für Tech 1 erstellt werden. Das bedarf einer Änderung in der Klasse Model:\nclass Model:\n    \"\"\"...\n    \"\"\"\n     \n    def __init__(self, n_agents, neighborhood_str, identifier):\n        \"\"\"...\n        \"\"\"\n        self.identifier = identifier\n        n_agents_pref_0 = int(n_agents / 2)\n        n_agents_pref_0 = n_agents - n_agents_pref_0\n        ag_pref_0 = [agent.Agent(0) for i in range(n_agents_pref_0)]\n        ag_pref_1 = [agent.Agent(1) for i in range(n_agents_pref_1)]\n        self.agentlist = ag_pref_0 + ag_pref_1"
  },
  {
    "objectID": "teaching/abm-de/index.html",
    "href": "teaching/abm-de/index.html",
    "title": "Eine Einführung in Agentenbasierte Modellierung mit Python",
    "section": "",
    "text": "Dieser Kurs richtet sich an Personen, die gerne mit agentenbasierten Modellen arbeiten möchten und dazu die Programmiersprache Python verwenden möchten. Der setzt keine Kenntnisse in Python voraus und beginnt mit einer sehr konzisen Einführung in die Sprache als solches, wobei der Fokus auf Konzepten liegt, die später beim agentenbasierten Modellieren besonders relevant sind.\nDer Kurs ist in mehrere Blöcke unterteilt, die alle als Playlist über Youtube verfügbar sind. Zudem gibt es Übungsaufgaben und entsprechende Lösungen. Fragen können sehr gerne über die Kommentarfunktion auf Youtube gestellt werden und auch Feedback jeglicher Art ist sehr willkommen."
  },
  {
    "objectID": "teaching/abm-de/index.html#footnotes",
    "href": "teaching/abm-de/index.html#footnotes",
    "title": "Eine Einführung in Agentenbasierte Modellierung mit Python",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSeitdem ich diesen Kurs erstellt habe bin ich selber auf Visual Studio Code als IDE gewechselt, das ich insgesamt besser finde.↩︎\nFür alle, die Daten bislang mit R visualisieren, könnte das neue Paket plotnine interessant sein, das sich stark am Design von ggplot2 orientiert.↩︎"
  },
  {
    "objectID": "teaching/index.html",
    "href": "teaching/index.html",
    "title": "Teaching",
    "section": "",
    "text": "Here I collect material for my courses. I try to publish as much of the material online after the course is completed. For more information about the teaching portfolio of my department at the Europa-University Flensburg, see here. Please get in touch if you have questions or suggestions.\n\nGeneral courses\n\n\n\n\nTitle\nKind\nPlace\nDate\n\n\n\n\nAn introduction to agent-based modeling in Python\nWeb-based course (scripts, videos (German), and tasks)\nOnline\nAlways open\n\n\nMacroeconomic models - a multi-paradigmatic introduction (German)\nWeb-based course (Scripts and videos in German)\nOnline\nAlways open\n\n\nEconomics Complexity: Theory and computational methods\nSummer School Course (1-semester-equivalent)\nExploring Economics Summer Academy\nAugust 2017, 2018, 2019\n\n\nAn introduction to Python and computational game theory\nMini course (3 days)\nUniversity of Szeged\nApril 2018\n\n\n\n\n\nUndergraduate courses\n\n\n\n\n\n\n\n\n\nTitle\nUniversity\nDate\n\n\n\n\nGoverning with numbers - the political economy of economic indicators\nUniversity of Erfurt\nWinter term 2018/19\n\n\nAgent-based modeling and Computional Social Sciences\nUniversity of Erfurt\nSummer term 2018\n\n\nExercises in Game Theory\nUniversity of Bremen\nSummer term 2014, 2015, 2016\n\n\nComputational Economics in R\nUniversity of Bremen\nWinter term 2015/16\n\n\nInnovation and Information Economics\nUniversity of Bremen\nWinter term 2014/15\n\n\nExercises in evolutionary and institutional economics\nUniversity of Bremen\nWinter term 2014/15, 2015/16\n\n\n\n\n\n\n\n\n\n\nGraduate and PhD level courses\n\n\n\n\nTitle\nUniversity\nDate\n\n\n\n\nData Science\nEuropa University Flensburg\nSpring semester 2022, Fall semester 2022/23\n\n\nEnvironmental Economics\nEuropa University Flensburg\nFall semester 2022/23\n\n\nPolitical Economy (dt.)\nEuropa University Flensburg\nFall semester 2021/22, 2022/23\n\n\nAdvanced Macroeconomics\nUniversity of Duisburg-Essen\nWinter term 2020/21\n\n\nEconomic history and economic theory\nUniversity of Duisburg-Essen\nSummer term 2020, 2021\n\n\nPhilosophy of Science and Socioeconomic Research Methods\nUniversity of Duisburg-Essen\nWinter term 2019/20,20/21, 21/22 Summer term 2020\n\n\nAgent-based modeling in economics\nCusanus University\nWinter term 2019/20\n\n\nGlobalization and Development\nUniversity of Duisburg-Essen\nSummer term 2019\n\n\nEconomic Methodology and Agent-based Modelling in Python\nUniversity of Siegen\nWinter term 2018/19\n\n\nIndividual and collective decision-making: lessons from game and complexity theory\nUniversity of Szeged\nWinter term 2017/18\n\n\nEvolutionary and institutional economics\nUniversity of Bremen\nSummer term 2015\n\n\nApplications of institutional and evolutionary economics\nUniversity of Bremen\nWinter term 2014/15"
  }
]