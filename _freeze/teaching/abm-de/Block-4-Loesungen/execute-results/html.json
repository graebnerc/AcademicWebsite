{
  "hash": "c814f1cfd08769055cc43fd8a9156c01",
  "result": {
    "markdown": "---\ntitle: Mögliche Lösungen zu den Aufgaben aus Block 4\nformat:\n  pdf:\n    toc: false\n  html:\n    toc: true\nexecute:\n  freeze: true\n---\n\nBeide Aufgaben beziehen sich auf die Implementierung des Arthur Modells, das in den Video Lectures entwickelt wurde. \nIhr könnt entweder eure eigene, oder die von mir vorbereitete Implementierung als Ausgangspunkt verwenden.\n\nIn den Hausaufgaben geht es vor allem darum, die Implementierung nachzuvollziehen. Dann sollt ihr die folgenden beiden Erweiterungen implementieren und die Effekte entsprechend visualisieren.\n\nDazu könnt ihr entweder neue subplots zu der vorgeschlagenen Visualisierung hinzufügen, eine neue Form der Visualisierung erstellen, oder einen der alten Fälle in der alten Visualisierung ersetzen.\n\n\n# Erweiterung des Arthur Modells I\n\n> Erstellt eine dritte Art der Nachbarschaft: hier sollen für jeden Agenten vier andere Agenten zufällig als Nachbard ausgewählt werden.\n\n*Hinweis 1: die Auswahl der Agenten kann durch die `numpy.random.choice` Funktion implementiert werden. Allerdings müsst  ihr sicherstellen, dass kein Agent zweimal gezogen wird, und dass kein Agent in seiner eigenen Nachbarschaft ist.*\n\n*Hinweis 2: In dieser Implementierung soll für einen Agent $i$, der Nachbar von Agent $j$ ist, nicht automatisch gelten, dass Nachbar $j$ ein Nachbar von Agent $i$ ist. Der Nachbarschaftsbegriff ist hier also weit: es kann auch bedeuten, dass sich Agent $i$ an Agent $j$ orientiert, aber nicht umgekehrt (z.B. weil $j$ ein Star, und $i$ ein follower ist).*\n\n## Hinweise zur Lösung\n\nDas Modell muss hierfür nicht fundamental geändert werden. \nDie folgenden Änderungen müssen durchgeführt werden:\n\n* In der `__init__` Funktion der Klasse `Model` muss die Möglichkeit zugelassen werden, dass die Nachbarschaft `random` spezifiziert wird.\n\n\n\n```{r}\nclass Model:\n    \"\"\"...   \n    \"\"\"\n     \n    def __init__(self, n_agents, neighborhood_str, identifier):\n        \"\"\"...\n        \"\"\"\n        # No change\n        assert neighborhood_str in [\"ring\", \"full\", \"random\"], \"No correct neighborhood \\\n        structure specified. Currently allowed: 'full' or 'ring' or 'random', but not {}\"\\\n        .format(neighborhood_str)\n        self.neighborhood = neighborhood_str\n```\n\n\n\n* Die Funktion `create_neighborhood_structure` muss ergänzt werden. Folgender Code wäre möglich:\n\n\n\n```{r}\nclass Model:\n    \"\"\"...\n    \"\"\"\n     \n    def __init__(self, n_agents, neighborhood_str, identifier):\n        \"\"\"...\n        \"\"\"\n    # No change\n        \n    def create_neighborhood_structure(self):\n        \"\"\"...\n        \"\"\"\n        if self.neighborhood == \"ring\":\n            print(\"Creating ring neighborhood...\", end=\"\")\n            # No change\n                \n        elif self.neighborhood == \"full\":\n            print(\"Creating full neighborhood...\", end=\"\")\n            # No change\n            \n        elif self.neighborhood == \"random\":\n            print(\"Creating random neighborhood...\", end=\"\")\n            for a in range(len(self.agentlist)):\n                neighborhood_choice_list = self.agentlist.remove(self.agentlist[a])\n                self.agentlist[a].add_neighbors(np.random.choice(self.agentlist, size=4, replace=False))\n```\n\n\n\nHierbei sind zwei Punkte zu beachten:\n* Wir müssen verhindern, dass der Agent sich selbst zu seiner Nachbarschaft hinzufügt indem man einer Variable `neighborhood_choice_list` erstellt, die alle Agenten außer dem Agenten selbst enthält\n* Wir müssen verhindern, dass ein Agent doppelt für die Nachbarschaft gezogen wird, das heißt `np.random.choice` muss mit dem Argumten `replace=False` aufgerufen werden. \n\n\n* Zuletzt muss noch die Klasse `Main` angepasst werden, indem auch Modellinstanzen mit einer zufälligen Nachbarschaft erstellt werden. Entsprechend muss das auch im `neighborhood_dict` berücksichtigt werden:\n\n\n\n```{r}\nclass Main:\n    \"\"\"...\n    \"\"\"\n    \n    def __init__(self, nb_agents, neighborhood_dict, outcome_filename):\n        # No change\n        self.nb_simulations = (self.neighborhood_dict[\"full\"] + \n                               self.neighborhood_dict[\"ring\"] + \n                               self.neighborhood_dict[\"random\"])\n        # No change\n        for i in range(self.neighborhood_dict[\"random\"]):\n            current_model = model.Model(self.nb_agents, \"random\", self.current_id)\n        # No change\n\nneigh_dict = {\"full\" : 20, # Nb of simulation runs with complete neigborhood \n              \"ring\" : 20, # Nb of simulation runs with ring neigborhood \n              \"random\" : 20}\n```\n\n\n\n\n# Erweiterung des Arthur Modells II\n\n> Verändert das Modell dahingehend, dass 50% der Agenten eine strikte Präferenz für Technologie 0 und 50% eine strikte Präferenz für Technologie 1 haben.\n\n*Hinweis: Eine Strikte Präferenz zeigt sich durch einen von Anfang an fixierten Wert für `agent.pref_tech_0`: für die Hälfte der Agenten soll dieser Wert $0.25$ sein, für die andere Hälfte $0.75$.*\n\n## Hinweise zur Lösung\nHier muss zunächst eine Änderung in der Klasse `Agent` vorgenommen werden:\nwir müssen ein zusätzliches Argument in der `__init__` Funktion hinzufügen, das spezifiziert ob der Agent entweder Technologie 0 oder Technologie ein setzt.\n\nEntsprechend muss dann die Funktion `tec_choice` leicht angepasst werden.\n\n\n\n```{r}\nclass Agent():\n    \"\"\"...\n    \"\"\"\n    \n    def __init__(self, pref_tech):\n        self.neighborhood = set()       \n        self.tech_chosen = None\n        if pref_tech == 0:\n            self.pref_tech_0 = 0.25\n        else:\n            self.pref_tech_0 = 0.75\n    \n    # No change\n    \n    def tec_choice(self):\n        \"\"\"...\n        \"\"\"\n        # No change\n        \n        # make technology choice \n        if len(techs_neighborhood) > 0:        \n            if self.pref_tech_0 < share_t1:\n                self.tech_chosen = 1\n            else:\n                self.tech_chosen = 0\n        else:\n            if self.pref_tech_0 < 0.5 :\n                self.tech_chosen = 1\n            else:\n                self.tech_chosen = 0\n```\n\n\n\nZuletzt muss dann noch sichergestellt werden, dass 50% der Agenten mit Präferenz für Tech 0 und 50% mit Präferenz für Tech 1 erstellt werden. Das bedarf einer Änderung in der Klasse `Model`:\n\n\n\n```{r}\nclass Model:\n    \"\"\"...\n    \"\"\"\n     \n    def __init__(self, n_agents, neighborhood_str, identifier):\n        \"\"\"...\n        \"\"\"\n        self.identifier = identifier\n        n_agents_pref_0 = int(n_agents / 2)\n        n_agents_pref_0 = n_agents - n_agents_pref_0\n        ag_pref_0 = [agent.Agent(0) for i in range(n_agents_pref_0)]\n        ag_pref_1 = [agent.Agent(1) for i in range(n_agents_pref_1)]\n        self.agentlist = ag_pref_0 + ag_pref_1\n```\n\n",
    "supporting": [
      "Block-4-Loesungen_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}