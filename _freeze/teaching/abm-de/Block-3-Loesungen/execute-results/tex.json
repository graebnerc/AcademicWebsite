{
  "hash": "86b7d585cf984f4e6b48089c890778b8",
  "result": {
    "markdown": "---\ntitle: Mögliche Lösungen zu den Aufgaben aus Block 3\nformat:\n  pdf:\n    toc: false\n  html:\n    toc: true\nexecute:\n  freeze: true\n---\n\n# Der zentrale Grenzwertsatz\n\n> Visualisiert die Funktion des [zentralen Grenzwertsatzes](https://en.wikipedia.org/wiki/Central_limit_theorem) anhand einer beliebigen Verteilung.\n\n*Hinweis: Der zentrale Grenzwertsatz besagt, dass die Mittelwerte aus vielen Stichproben, die unabhängig voneinander gezogen werden, normalverteilt sind, unabhängig von der zugrundeliegenden Verteilung. Um das zu zeigen, müsst ihr viele Stichproben einer Verteilung ziehen (nicht der Normalverteilung), jedes Mal den Mittelwert berechnen, und dann ein Histogramm dieser Mittelwerte erstellen. Je mehr Stichproben ihr berücksichtigt, desto ähnlicher sollte die Verteilung einer Normalverteilung werden.*\n\n**Solution**: For the solution I use the Poisson distribution with $\\lambda=1$. As you can verify from the following plot it does not look like a normal distribution at all:\n\n$$x^2+y3+\\frac{2}{3}$$\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom scipy import stats\npmf_poisson = stats.poisson.pmf(np.linspace(0,20, 21, dtype=int), 1.0)  \npdf_normal = stats.norm.pdf(np.linspace(-5,5, 200))\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfig, ax = plt.subplots(2,1)\nax[0].spines[\"top\"].set_visible(False) # Remove plot frame line on the top \nax[0].spines[\"right\"].set_visible(False) # Remove plot frame line on the right\nax[0].get_xaxis().tick_bottom()  # Remove ticks on the bottom\nax[0].get_yaxis().tick_left()  # Remove the ticks on the left\nax[0].plot(np.linspace(0,20, 21), pmf_poisson, color=\"#801a00\", marker=\"o\")\nax[0].set_title(\"PMF of the poisson distribution with lambda=1\")\n\nax[1].spines[\"top\"].set_visible(False) # Remove plot frame line on the top \nax[1].spines[\"right\"].set_visible(False) # Remove plot frame line on the right\nax[1].get_xaxis().tick_bottom()  # Remove ticks on the bottom\nax[1].get_yaxis().tick_left()  # Remove the ticks on the left\nax[1].plot(np.linspace(-5, 5, 200), pdf_normal, color=\"#801a00\")\nax[1].set_title(\"PDF of the standard normal distribution\")\nfig.tight_layout()\n```\n\n::: {.cell-output .cell-output-display}\n![](Block-3-Loesungen_files/figure-pdf/cell-3-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n1. Create many samples from the Poisson distribution and calculate the mean\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nsample_size = 100\n\nn = 10\npoisson_mean_n10 = [np.mean(np.random.poisson(lam=1.0, size=sample_size)) for i in range(n)]\nn = 1000\npoisson_mean_n1000 = [np.mean(np.random.poisson(lam=1.0, size=sample_size)) for i in range(n)]\nn = 5000\npoisson_mean_n5000 = [np.mean(np.random.poisson(lam=1.0, size=sample_size)) for i in range(n)]\nn = 50000\npoisson_mean_n50000 = [np.mean(np.random.poisson(lam=1.0, size=sample_size)) for i in range(n)]\n```\n:::\n\n\n2. Fit normals to the samples\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nn10_parameters = stats.norm.fit(poisson_mean_n10)\nn10_pdf = stats.norm.pdf(np.linspace(0,2, 200), loc=n10_parameters[0], scale=n10_parameters[1])\n\nn1000_parameters = stats.norm.fit(poisson_mean_n1000)\nn1000_pdf = stats.norm.pdf(np.linspace(0,2, 200), loc=n1000_parameters[0], scale=n1000_parameters[1])\n\nn5000_parameters = stats.norm.fit(poisson_mean_n5000)\nn5000_pdf = stats.norm.pdf(np.linspace(0,2, 200), loc=n5000_parameters[0], scale=n5000_parameters[1])\n\nn50000_parameters = stats.norm.fit(poisson_mean_n50000)\nn50000_pdf = stats.norm.pdf(np.linspace(0,2, 200), loc=n50000_parameters[0], scale=n50000_parameters[1])\n```\n:::\n\n\n3. Visualize the results\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nfig, axes = plt.subplots(2,2, figsize=(12, 9))\n\naxes[0,0].spines[\"top\"].set_visible(False) # Remove plot frame line on the top \naxes[0,0].spines[\"right\"].set_visible(False) # Remove plot frame line on the right\naxes[0,0].get_xaxis().tick_bottom()  # Remove ticks on the bottom\naxes[0,0].get_yaxis().tick_left()  # Remove the ticks on the left\naxes[0,0].hist(poisson_mean_n10, color=\"#3F5D7D\", bins=\"auto\", density=True)\naxes[0,0].set_title(\"10 Samples\")\naxes[0,0].plot(np.linspace(0, 2, 200), n10_pdf, color=\"#801a00\")\n\naxes[0,1].spines[\"top\"].set_visible(False) # Remove plot frame line on the top \naxes[0,1].spines[\"right\"].set_visible(False) # Remove plot frame line on the right\naxes[0,1].get_xaxis().tick_bottom()  # Remove ticks on the bottom\naxes[0,1].get_yaxis().tick_left()  # Remove the ticks on the left\naxes[0,1].hist(poisson_mean_n1000, color=\"#3F5D7D\", bins=\"auto\", density=True)\naxes[0,1].set_title(\"1000 Samples\")\naxes[0,1].plot(np.linspace(0, 2, 200), n1000_pdf, color=\"#801a00\")\n\naxes[1,0].spines[\"top\"].set_visible(False) # Remove plot frame line on the top \naxes[1,0].spines[\"right\"].set_visible(False) # Remove plot frame line on the right\naxes[1,0].get_xaxis().tick_bottom()  # Remove ticks on the bottom\naxes[1,0].get_yaxis().tick_left()  # Remove the ticks on the left\naxes[1,0].hist(poisson_mean_n5000, color=\"#3F5D7D\", bins=\"auto\", density=True)\naxes[1,0].set_title(\"5000 Samples\")\naxes[1,0].plot(np.linspace(0, 2, 200), n5000_pdf, color=\"#801a00\")\n\naxes[1,1].spines[\"top\"].set_visible(False) # Remove plot frame line on the top \naxes[1,1].spines[\"right\"].set_visible(False) # Remove plot frame line on the right\naxes[1,1].get_xaxis().tick_bottom()  # Remove ticks on the bottom\naxes[1,1].get_yaxis().tick_left()  # Remove the ticks on the left\naxes[1,1].hist(poisson_mean_n50000, color=\"#3F5D7D\", bins=95, density=True)\naxes[1,1].set_title(\"50000 Samples\")\naxes[1,1].plot(np.linspace(0, 2, 200), n50000_pdf, color=\"#801a00\")\nfig.tight_layout()\n```\n\n::: {.cell-output .cell-output-display}\n![](Block-3-Loesungen_files/figure-pdf/cell-6-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n# Das Gesetz der großen Zahl\n\n> Visualisiert die Implikationen vom [Gesetz der großen Zahl](https://en.wikipedia.org/wiki/Law_of_large_numbers).\n\n*Hinweis: Das Gesetz der großen Zahl besagt, dass bei wachsender Stichprobengröße der Mittelwert (und oft weitere Momente) der Stichprobe zum wahren Mittelwert (bzw. den wahren Momenten) der zugrundeliegenden Verteilung konvergiert. Um das zu zeigen könnt ihr vier verschiedene Histogramme darstellen, die alle auf Basis unterschiedlich großer Stichproben erstellt wurden. Im Skript findet sich eine ähnliche Anwendung*.\n\n**Lösung**: Hier wird das Gesetz anhand der Normalverteilung illustriert. \nWir setzen einen Mittelwert von 1.0 selbst fest.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nsample_sizes = np.linspace(10, 10000, 10, dtype=int)\nsample_means = [np.mean(np.random.normal(loc=1.0, size=x)) for x in sample_sizes]\n```\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nfig, ax = plt.subplots()\nax.plot(sample_sizes, sample_means)\nax.plot(sample_sizes, [1.0]*len(sample_sizes))\nfig.tight_layout()\n```\n\n::: {.cell-output .cell-output-display}\n![](Block-3-Loesungen_files/figure-pdf/cell-8-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nMan beachte jedoch, dass dieses Gesetz nicht für alle Verteilungen gilt!\n\n# Zusatzaufgabe: Anwendung & Verbindung mit OOP\n\nProgrammiert ein ABM, in dem zwei Spieler miteinander folgendes Spiel spielen:\nsie werfen eine Münze und bei Kopf gewinnt der erste Spieler (i.e. er oder sie bekommt einen Punkt), bei Zahl gewinnt der zweite Spieler (i.e. er oder sie bekommt einen Punkt).\n\nHierzu benötigt ihr zwei Klassen:\n\n1. Eine Klasse `Spieler`. Diese Klasse sollte als Instanzeneigenschaft die Menge an bisher gesammelten Punkten haben (sollte mit 0 anfangen), sowie Information darüber ob der Spieler bei Kopf oder Zahl gewinnt (sollte über `__init__` festgelegt werden). Außerdem sollte sie eine Instanzenfunktion haben, die als Argument den Ausgang eines Münzwurfs nimmt und die gesammelten Punkte entsprechend anpasst.\n\n2. Eine Klasse `Spiel`, die als Instanzeneigenschaft die Liste der beiden Spieler hat und eine Instanzenfunktion besitzt, die einen Münzwurf simuliert.\n\nLasst die Spieler das Spiel 100 Mal spielen.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nclass Spieler:\n    def __init__(self, gewinnerseite):\n        self.points = 0\n        self.win_side = gewinnerseite\n        \n    def get_points(self, side):\n        if side == self.win_side:\n            self.points += 1\n\nclass Spiel:\n    def __init__(self):\n        self.players = [Spieler(\"Kopf\"), Spieler(\"Zahl\")]\n        \n    def throw_coin(self):\n        if np.random.randint(0, 2) == 0:\n            result = \"Kopf\"\n        else:\n            result = \"Zahl\"\n        for a in self.players:\n            a.get_points(result)\n\nspiel = Spiel()\nfor i in range(1000):\n    spiel.throw_coin()\n\nfig, ax = plt.subplots()\nax.bar(x = [\"Spieler 1\",\"Spieler 2\"], height=[spiel.players[0].points, spiel.players[1].points])\nax.set_title(\"Punkte der Spieler nach 1000 Würfen\")\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nText(0.5, 1.0, 'Punkte der Spieler nach 1000 Würfen')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](Block-3-Loesungen_files/figure-pdf/cell-9-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n",
    "supporting": [
      "Block-3-Loesungen_files"
    ],
    "filters": []
  }
}