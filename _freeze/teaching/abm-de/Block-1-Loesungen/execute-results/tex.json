{
  "hash": "58f50d8b5bd3cb7732ebbadcc3db9e27",
  "result": {
    "markdown": "---\ntitle: Mögliche Lösungen zu den Aufgaben aus Block 1\nformat:\n  pdf:\n    toc: false\n  html:\n    toc: true\nexecute:\n  freeze: true\n---\n\n# Aufgabenblock 1: Grundlagen\n\n**1.1.** Kreiert eine Liste mit den Zahlen von 1 bis 10. \nSpeichert diese Liste unter dem Namen 'l_1' und lasst Python die Liste ausgeben (mit Hilfe der `print` Funktion).\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nl_1 = list(range(1,11)) \nprint(l_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n:::\n:::\n\n\n**1.2.** Extrahiert das das dritte Element aus dieser Liste, assoziiert es in einer Variable und gebt diese aus.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nl_1_e3 = l_1[2]\nprint(l_1_e3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n```\n:::\n:::\n\n\n**1.3.** Extrahiert die letzten drei Elemente der Liste und gebt sie aus.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nprint(l_1[-3:])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[8, 9, 10]\n```\n:::\n:::\n\n\n**1.4.** Ersetzt den ersten Wert der Liste mit der Zahl $99.9$.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nl_1[0] = 99.9\n```\n:::\n\n\n**1.5.** Sortiert die Elemente der Liste in absteigender Reihenfolge.\nGebt sie danach über den `print` Befehl aus.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nl_1.sort(reverse=True)\nprint(l_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[99.9, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n```\n:::\n:::\n\n\n**1.6.** Definiert die folgenden zwei Mengen:\n\n\\begin{align*}\nm_1 &= \\{1, 4, 23, 95, 12\\}\\\\\nm_2 &= \\{0, 23, 80, 96, 95\\}\\\\\n\\end{align*}\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nm_1 = {1, 4, 23, 95, 12}\nm_2 = {0, 23, 80, 96, 95}\n```\n:::\n\n\n**1.7.** Welche Elemente sind in $m_1$, aber nicht in $m_2$? Speichert diese Elemente *in einer Liste* und gebt diese aus.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nl_diff = list(m_1 - m_2)\nprint(l_diff)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 4, 12]\n```\n:::\n:::\n\n\n**1.8.** Speichert die Schnittmenge von $m_1$ und $m_2$ über eine Variable und lasst Python diese Variable ausgeben.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nm_intersec = m_1 & m_2\nprint(m_intersec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{95, 23}\n```\n:::\n:::\n\n\n**1.9.** Kreiert ein Wörterbuch mit den folgenden *key-value* Paaren:\n\n- \"Hello\" and \"Hola\"\n- 5 and 120.5\n- \"bla\" and [10, 80]\n\nRuft dann den zu 'bla' gehörenden value auf.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ndic_1 = {\"Hello\" : \"Hola\", 5 : 120.5, \"bla\" : [10, 80]}\ndic_1[\"bla\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n[10, 80]\n```\n:::\n:::\n\n\n# Aufgabenblock 2: Funktionen\n\n**2.1.**Definiert eine Funktion, die folgende Gleichung berechnet:\n\n$$f(x,y) = 10x+(1-y)^2$$\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ndef func_expl(x,y):\n    result = 10 * x + (1-y)**2\n    return result\n\nfunc_expl(2,1)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n20\n```\n:::\n:::\n\n\n**2.2.** Ergänzt die Funktion, sodass sie überprüft ob als Inputs nur ganze Zahlen eingegeben wurden (int).\nWenn ein Input keine ganze Zahl ist soll eine Fehlermeldung ausgegeben werden.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ndef func_expl(x,y):\n    assert isinstance(x, int), \"Input x kein integer, sonder {}\".format(type(x))\n    assert isinstance(y, int), \"Input y kein integer, sonder {}\".format(type(y))\n    result = 10 * x + (1-y)**2\n    return result\n\nfunc_expl(2,3.0)\n```\n\n::: {.cell-output .cell-output-error}\n```\nAssertionError: Input y kein integer, sonder <class 'float'>\n```\n:::\n:::\n\n\n# Aufgabenblock 3: Loops\n\n**3.1.** Erstelle eine Liste mit den Wurzeln der Zahlen zwischen 5 und 15. \nStelle die Lösung sowohl als `for loop` also auch als `list comprehension` dar.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nl_loop = []\nfor i in range(5,16):\n    l_loop.append(i**0.5)\n\nl_comp = [x**0.5 for x in range(5, 16)]\n\nprint(l_loop)\nprint(l_comp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2.23606797749979, 2.449489742783178, 2.6457513110645907, 2.8284271247461903, 3.0, 3.1622776601683795, 3.3166247903554, 3.4641016151377544, 3.605551275463989, 3.7416573867739413, 3.872983346207417]\n[2.23606797749979, 2.449489742783178, 2.6457513110645907, 2.8284271247461903, 3.0, 3.1622776601683795, 3.3166247903554, 3.4641016151377544, 3.605551275463989, 3.7416573867739413, 3.872983346207417]\n```\n:::\n:::\n\n\n**3.2.** Betrachte den folgenden `for loop`:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nl_1 = [0, 2, \"Land\", \"!\"]\nl_2 = [\"Lame\", \"La\", 1, 3]\nfor i in l_1:\n    print(i * l_2[i], end=\" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n 2 \n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nTypeError: list indices must be integers or slices, not str\n```\n:::\n:::\n\n\nDieser loop funktioniert so nicht!\nSchreibe den loop so um, dass er nicht über die einzelnen Elemente von `l_1`, sondern über die Indices von `l_1` iteriert. \n\n*Gewünschtes Ergebnis: \"LaLa Land!!!*\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nl_1 = [0, 2, \"Land\", \"!\"]\nl_2 = [\"Lame\", \"La\", 1, 3]\nfor i in range(len(l_1)):\n    print(l_1[i] * l_2[i], end=\" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n LaLa Land !!! \n```\n:::\n:::\n\n\n**3.3.** Wie oft muss man $1.1$ quadrieren bis das Ergebnis größer als 10 ist?\nVerwende einen `while loop` um diese Frage zu beantworten. \n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\ncounter = 0\ncurrent_val = 1.1\nwhile current_val <= 10:\n    current_val = current_val**2\n    counter += 1\nprint(current_val)\nprint(counter)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n21.1137767453526\n5\n```\n:::\n:::\n\n\n**3.4.** Definiert eine Funktion, welche die folgende Gleichung implementiert:\n\n$$f(x) = \\frac{1}{x} + \\frac{1}{x^2}$$\n\nNehmt als Startwert $x_0=2$ und berechnet die Zeitreihe, welche durch diese Funktion für 7 Zeitschritte kreiert.\n\n*Erläuterung*: Ihr könnt die von euch definierte Funktion in einen `for loop` einbauen, sodass sie in jedem Zeitschritt ihren Output aus dem Zeitschritt davor als Input erhält.  \n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\ndef func_ex_2(x):\n    result = (1/x) + 1/x**2\n    return result\n\nts = [2]\nfor t in range(7):\n    ts.append(func_ex_2(ts[-1]))\nts\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n[2,\n 0.75,\n 3.1111111111111107,\n 0.42474489795918374,\n 7.897338780221661,\n 0.1426588076214919,\n 56.14607377836738,\n 0.018127904872052552]\n```\n:::\n:::\n\n\nHier nur als Illustration wie die Zeitreihe aussieht:\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nplt.plot(range(8), ts)\n```\n\n::: {.cell-output .cell-output-display}\n![](Block-1-Loesungen_files/figure-pdf/cell-18-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n",
    "supporting": [
      "Block-1-Loesungen_files/figure-pdf"
    ],
    "filters": []
  }
}