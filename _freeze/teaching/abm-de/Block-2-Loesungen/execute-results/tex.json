{
  "hash": "37e355d79d93c85763c5411f678bb3b3",
  "result": {
    "markdown": "---\ntitle: Mögliche Lösungen zu den Aufgaben aus Block 2\nformat:\n  pdf:\n    toc: false\n  html:\n    toc: true\nexecute:\n  freeze: true\n---\n\n# Aufgabenblock 1: Die Studentenklasse\n\nIn der Videolecture haben wir die folgende Klasse `Student` entwickelt:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nclass Student:\n    \"\"\"\n    This is a class called student.\n    \"\"\"\n    profession = \"student\"\n    \n    def __init__(self, name, affiliation):\n        self.name = name\n        self.affiliation = affiliation\n        self.beers = 0\n        self.credits = 0\n        self.friends = set()\n        \n    def __repr__(self):\n        return self.name\n    \n    def drink(self, beers):\n        self.beers += beers\n        return beers*[\"Cheers!\"]\n    \n    def study(self, cp_earned):\n        self.credits += cp_earned\n    \n    def make_friend(self, new_friend):\n        assert isinstance(new_friend, Student), \"A student can only befriend other students!\"\n        self.friends.add(new_friend)\n    \n    def drink_with_friends(self, beers):\n        for f in self.friends:\n            f.drink(beers)\n            self.drink(beers)\n```\n:::\n\n\n**Aufgabe 1.1:** Ergänze die `__repr__` Funktion des Studenten, sodass sie nicht nur seinen Namen, sondern auch die Anzahl der Credits und der Biere augegeben werden.\nWenn die Instanz des Studierenden aufgerufen wird, soll die Ausgabe in etwa folgendermaßen ausseßen (vorausgesetzt, die Studenting heißt Claire, hat 5 Biere getrunken, und 10 credits erhalten):\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nprint(\"Claire (5 Biere und 10 Credits)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nClaire (5 Biere und 10 Credits)\n```\n:::\n:::\n\n\n*Hinweis:* Denkt daran, dass ihr einzelne Strings mit dem Additionsoperator `+` miteinender verbinden könnt:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n\"Hallo\" + \" und \" + \"Tschuess!\"\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n'Hallo und Tschuess!'\n```\n:::\n:::\n\n\n*Hinweis 2:* Das funktioniert nur mit strings! Zahlen müssen vorher in strings umgewandelt werden (siehe Funktion `str`).\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nclass Student:\n    \"\"\"\n    This is a class called student.\n    \"\"\"\n    profession = \"student\"\n    \n    def __init__(self, name, affiliation):\n        self.name = name\n        self.affiliation = affiliation\n        self.beers = 0\n        self.credits = 0\n        self.friends = set()\n        \n    def __repr__(self):\n        return_val = self.name + \" (\" + str(self.beers) + \" Biere und \" + str(self.credits) + \" Credits)\"\n        return return_val\n    \n    def drink(self, beers):\n        self.beers += beers\n        return beers*[\"Cheers!\"]\n    \n    def study(self, cp_earned):\n        self.credits += cp_earned\n    \n    def make_friend(self, new_friend):\n        assert isinstance(new_friend, Student), \"A student can only befriend other students!\"\n        self.friends.add(new_friend)\n    \n    def drink_with_friends(self, beers):\n        for f in self.friends:\n            f.drink(beers)\n            self.drink(beers)\nclaire = Student(\"Claire\", \"Uni Erfurt\")\nclaire\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nClaire (0 Biere und 0 Credits)\n```\n:::\n:::\n\n\n**Aufgabe 1.2:** Ergänzt die `__init__` Funktion, sodass jede Instanz des Studenten auch ein Instanzenattribut `title` hat. Dieses soll bei Instanziierung eines Studenten zunächst den Wert `'nichts'` haben.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nclass Student:\n    \"\"\"\n    This is a class called student.\n    \"\"\"\n    profession = \"student\"\n    \n    def __init__(self, name, affiliation):\n        self.name = name\n        self.affiliation = affiliation\n        self.beers = 0\n        self.credits = 0\n        self.friends = set()\n        self.title = \"nichts\"\n        \n    def __repr__(self):\n        return_val = self.name + \" (\" + str(self.beers) + \" Biere und \" + str(self.credits) + \" Credits)\"\n        return return_val\n    \n    def drink(self, beers):\n        self.beers += beers\n        return beers*[\"Cheers!\"]\n    \n    def study(self, cp_earned):\n        self.credits += cp_earned\n    \n    def make_friend(self, new_friend):\n        assert isinstance(new_friend, Student), \"A student can only befriend other students!\"\n        self.friends.add(new_friend)\n    \n    def drink_with_friends(self, beers):\n        for f in self.friends:\n            f.drink(beers)\n            self.drink(beers)\nclaire = Student(\"Claire\", \"Uni Erfurt\")\nclaire.title\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n'nichts'\n```\n:::\n:::\n\n\n**Aufgabe 1.3:** Ergänze die Klasse `Student` um eine neue Instanzenfunktion namens `graduate`.\nDiese Funktion soll überprüfen ob der Studierende mindestens 180 credits und 90 Biere hat.\n\nFalls ja, soll das Attribut `title` auf den String `'BA'` geändert werden.\nZudem soll dann die Funktion `drink_with_friends` mit 10 Bieren aufgerufen werden und eine Meldung (durch `print`) ausgegeben werden, dass der Student jetzt graduiert ist.\n\nFalls nein, soll nur eine Meldung (durch `print` ausgegeben werden), dass der Student noch nicht graduieren kann.\n\n*Hinweis:* Mehrere Abfragen in if/else statements können durch das `and` Keyword durchgeführt werden:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n(2<3) and (4>2)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n(2<3) and (2>2)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nFalse\n```\n:::\n:::\n\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nclass Student:\n    \"\"\"\n    This is a class called student.\n    \"\"\"\n    profession = \"student\"\n    \n    def __init__(self, name, affiliation):\n        self.name = name\n        self.affiliation = affiliation\n        self.beers = 0\n        self.credits = 0\n        self.friends = set()\n        self.title = \"nichts\"\n        \n    def __repr__(self):\n        return_val = self.name + \" (\" + str(self.beers) + \" Biere und \" + str(self.credits) + \" Credits)\"\n        return return_val\n    \n    def drink(self, beers):\n        self.beers += beers\n        return beers*[\"Cheers!\"]\n    \n    def study(self, cp_earned):\n        self.credits += cp_earned\n    \n    def make_friend(self, new_friend):\n        assert isinstance(new_friend, Student), \"A student can only befriend other students!\"\n        self.friends.add(new_friend)\n    \n    def drink_with_friends(self, beers):\n        for f in self.friends:\n            f.drink(beers)\n            self.drink(beers)\n            \n    def graduate(self):\n        if (self.credits>=180) and (self.beers>=90):\n            self.title = \"BA\"\n            self.drink_with_friends(10)\n            print(\"Hurra! Graduiert!\")\n        else:\n            print(\"Oh weh, kann noch nicht graduieren...\")\n            \nclaire = Student(\"Claire\", \"Uni Erfurt\")\nclaire.graduate()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOh weh, kann noch nicht graduieren...\n```\n:::\n:::\n\n\n**Aufgabe 1.4:** Erstellt eine Instanz der Klasse `Student` und lasst sie so lange trinken und lernen, bis sie graduieren kann.\nDann lasst sie graduieren.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nclaire = Student(\"Claire\", \"Uni Erfurt\")\nclaire.study(180)\nclaire.drink(90)\nclaire.graduate()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHurra! Graduiert!\n```\n:::\n:::\n\n\n**Aufgabe 1.5:** Schreibt eine Klasse `FlunkyBall`. Diese Klasse soll zwei Teams erstellen, die jeweils aus einer gleichen Anzahl von `Studenten` bestehen sollen.\nDie Anzahl der Studenten pro Team soll als Argument der `__init__` Funktion gegeben werden.\n\nDann soll die Klasse über eine Funktion `play` verfügen: \ndiese Funktion nimmt ein Argument an. \nDieses Argument spezifiziert, welches der Teams verliert. \nAlle Mitglieder des Verliererteams müssen nun ein Bier trinken.\n\n*Hinweis 1:* Hier müssen wahrscheinlich if/else Befehle verwendet werden.\n\n*Hinweis 2:* Ihr könnt euch hier ein wenig an der Klasse `StuRa` orientieren, die wir in den Video Lectures erstellt haben:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nclass StuRa:\n    \"\"\"\n    A class for StuRas\n    \"\"\"\n    function = \"Organisation der Studis\"\n    \n    def __init__(self, members):\n        assert isinstance(members, set), \"Members must given as set!\"\n        for m in members:\n            assert isinstance(m, Student), \"Members as such must be students!\"\n        self.members = members\n    \n    def befriend_members(self):\n        \"\"\"\n        Befriends all members.\n        \"\"\"\n        for m in self.members:\n            for n in self.members:\n                if m is not n:\n                    m.make_friend(n)\n    \n    def hard_work(self, amount_work):\n        for m in self.members:\n            print(m, \"works hard!\")\n            m.drink(amount_work)\n```\n:::\n\n\n*Hinweis 3:* Wir haben in den Video lectures gesehen wie man einfach eine größere Menge Studenten erstellt:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nn_students = 10\nlist_of_students = {Student(\"student_\" + str(x), \"Uni Erfurt\") for x in range(n_students)}\n```\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nclass FlunkyBall:\n    def __init__(self, n_players):\n        self.team_1 = {Student(\"student_\" + str(x), \"Uni Erfurt\") for x in range(int(n_players/2))}\n        self.team_2 = {Student(\"student_\" + str(x), \"Uni Erfurt\") for x in range(int(n_players/2), n_players)}\n        \n    def play(self, winner):\n        assert (winner==1) or (winner==2), \"Must specify team 1 or 2!\"\n        if winner == 1:\n            for m in self.team_2:\n                m.drink(1)\n        else:\n            for m in self.team_1:\n                m.dring(1)\n\nfunny_flunky = FlunkyBall(10)\nfunny_flunky.play(1)\n```\n:::\n\n\n# Aufgabenblock 2: Das Solow Wachstumsmodell\n\nIn dieser Aufgabe sollt ihr eine Version von [Solow's Wachstumsmodell](https://en.wikipedia.org/wiki/Solow%E2%80%93Swan_model) erstellen.\nKlingt anspruchsvoll, aber mit ein paar Hinweisen könnt könnt ihr das schon!\n\n**Erster Schritt: Eine Klasse für die Ökonomie!**:\nAls erster Schritt müsst ihr eine Klasse `Economy` erstellen.\n\nDiese Klasse soll *drei Instanzeneigenschaften* haben: `capital`, `labor`, und `bip`.\nDiese Klasseneigenschaften sollen jeweils aus einer Liste bestehen.\nDeren erstes Element soll für `capital` und `labor` als Argument an die `__init__` Funktion übergeben werden.\n`bip` soll als leere Liste instantiiert werden.\n\nAls Starthilfe hier schon einmal folgendes Grundgerüst, das ihr weiterverwenden könnt:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nclass Economy:\n    \"\"\"\n    An economy.\n    \"\"\"\n    def __init__(self, ):\n        self.capital = capital\n        self.labor\n        self.\n```\n:::\n\n\nDie Lösung wäre:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nclass Economy:\n    \"\"\"\n    An economy.\n    \"\"\"\n    def __init__(self, ):\n        self.capital = [capital]\n        self.labor = [labor]\n        self.bip = []\n```\n:::\n\n\n**Zweiter Schritt: Eine Funktion für das BIP**:\nIm nächsten Schritt müsst ihr eine Klassenfunktion schreiben, die für die aktuellen Werte von `capital` und `labor` den entsprechenden Wert für `BIP` berechnet.\n\nDas Solow Wachstumsmodell verwendet hierfür ein *Cobb-Douglas* Produktionsfunktion:\n\n$$Y_t = K_t^\\alpha L_t^{1-\\alpha}$$\n\nDas bedeutet: der Wert für das BIP ($Y$ in der Gleichung) zum Zeitpunkt $t$ beträgt der aktuelle Kapitelstock exponiert mit dem Wert $\\alpha$ multipliziert mit der Arbeitskraft der Ökonomie ($L$ in der Gleichung), exponiert mit dem Wert ($1-\\alpha$).\n\nAußerhalb einer Klasse können wir diese Funktion folgendermaßen in Python implementieren:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\ndef cobb_douglas(capital, labor, alpha):\n    bip = capital**alpha * labor**(1-alpha)\n    return bip\n```\n:::\n\n\nImplementiert diese Funktion als Klassenfunktion in der Klasse `Economy`. Vergesst nicht, dass `self` Argument hinzuzufügen!\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nclass Economy:\n    \"\"\"\n    An economy.\n    \"\"\"\n    def __init__(self, capital, labor ):\n        self.capital = [capital]\n        self.labor = [labor]\n        self.bip = []\n    \n    def cobb_douglas(self, capital, labor, alpha):\n        bip = capital**alpha * labor**(1-alpha)\n        return bip\n\nexpl_econ = Economy(5, 10)\n```\n:::\n\n\n**Dritter Schritt: Anpassung der Basisklasse**: Wir sind schon bald fertig!\nErgänzt nun die `__init__` Funktion eurer Klasse `Economy` sodass sie ein weiteres Argument annimmt: `alpha`.\nDieses soll als Instanzenattribut gespeichert werden, genauso wie `capital`, `labor` und `bip`, nur nicht als liste, sondern als `float`.\n\nAuch könnt ihr nun die Instanzenfunktion `cobb_douglas` anpassen: sie soll nun nicht mehr `alpha` als Argument nehmen.\nVielmehr kann sie `alpha` direkt als Instanzenattribut ansprechen.\n\nDas ist ähnlich als ob bei der Funktion oben `alpha` vorher außerhalb der Funktion definiert worden wäre.\nIhr müsst diese Logik nur an euren Klassenkontext angepasst werden (denkt an die Rolle von `self`):\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nalpha = 0.5\ndef cobb_douglas(capital, labor):\n    bip = capital**alpha * labor**(1-alpha)\n    return bip\ncobb_douglas(10, 20)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n14.142135623730953\n```\n:::\n:::\n\n\n*Hinweis*:\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nclass Economy:\n    \"\"\"\n    An economy.\n    \"\"\"\n    def __init__(self, alpha, ):\n        self.alpha = \n        self.capital = capital\n        self.labor\n        self.\n```\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nclass Economy:\n    \"\"\"\n    An economy.\n    \"\"\"\n    def __init__(self, alpha, capital, labor):\n        self.capital = [capital]\n        self.labor = [labor]\n        self.bip = []\n        self.alpha = alpha\n    \n    def cobb_douglas(self, capital, labor):\n        bip = capital**self.alpha * labor**(1-self.alpha)\n        return bip\n\nexpl_econ = Economy(0.5, 10, 20)\n```\n:::\n\n\n**Vierter Schritt: Ersten BIP Wert berechnen** Ihr müsst nun ein letztes Mal die `__init__` Funktion anpassen:\nsie soll den ersten Wert für `self.bip` mit der Funktion `cobb_douglas` festlegen.\n\n*Hinweis*:\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nclass Economy:\n    \"\"\"\n    An economy.\n    \"\"\"\n    def __init__(self, alpha, ):\n        self.alpha = \n        self.capital = capital\n        self.labor\n        self.bip = []\n        self.bip.append(self.cobb_douglas(self.capital[-1], self. ))\n```\n:::\n\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nclass Economy:\n    \"\"\"\n    An economy.\n    \"\"\"\n    def __init__(self, alpha, capital, labor):\n        self.alpha = alpha\n        self.capital = [capital]\n        self.labor = [labor]\n        self.bip = []\n        self.bip.append(self.cobb_douglas(self.capital[-1], self.labor[-1]))\n\n    \n    def cobb_douglas(self, capital, labor):\n        bip = capital**self.alpha * labor**(1-self.alpha)\n        return bip\n\nexpl_econ = Economy(0.5, 10, 20)\nexpl_econ.bip\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n[14.142135623730953]\n```\n:::\n:::\n\n\n**Fünfter Schritt: Die Zeitschritte**:\nIhr müsst nun eine weitere Instanzenfunktion hinzufügen: `timestep`.\nDiese Funktion nimmt als Input die aktuellen Werte von `capital`, `labor` und `bip` und berechnet den Wert für den nächsten Zeitschritt.\n\nDie *Veränderungen* von `capital` und `labor` ergeben sich aus dem Investment in neues Kapital, der Kapitalabnutzung und dem Bevölkerungswachstum. \nDiese Veränderungen lassen sich durch folgende beiden Funktionen berechnen, die voraussetzen, dass $5\\%$ des BIP in Kapital investiert wird, $6\\%$ des aktuellen Kapitalstocks abgenutzt werden, und die Bevölkerung mit $3\\%$ pro Zeitschritt wächst.\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nclass Economy:\n    def change_capital(self):\n        change_of_capital = self.bip[-1]*0.05 - self.capital[-1]*0.06\n        return change_of_capital\n    \n    def change_labor(self):\n        change_of_labor = self.labor[-1]*0.03\n        return change_of_labor\n```\n:::\n\n\n*Hinweis*: Die `[-1]` Notation ruft das letzte Element einer Liste auf:\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nl_1 = [1,2,3,4]\nl_1[-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n4\n```\n:::\n:::\n\n\nDie Funktion `timestep` soll also alle drei Update Funktionen aufrufen, die neuen Werte berechnen, und an die Listen für `capital`, `labor` und `bip` anhängen (mit der `append` Methode).\n\nFolgender Hinweis ist vielleicht hilfreich:\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nclass Economy:\n    def change_capital(self):\n        change_of_capital = self.bip[-1]*0.05 - self.capital[-1]*0.06\n        return change_of_capital\n    \n    def timestep(self):\n        capital_change = self.change_capital()\n        capital_new = self.capital[-1] + capital_change capital\n        self.capital.append(capital_new)\n        # similar operations for labor and bip\n```\n:::\n\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nclass Economy:\n    \"\"\"\n    An economy.\n    \"\"\"\n    def __init__(self, alpha, capital, labor):\n        self.alpha = alpha\n        self.capital = [capital]\n        self.labor = [labor]\n        self.bip = []\n    \n    def cobb_douglas(self, capital, labor):\n        bip = capital**self.alpha * labor**(1-self.alpha)\n        return bip\n    \n    def change_capital(self):\n        change_of_capital = self.bip[-1]*0.05 - self.capital[-1]*0.06\n        return change_of_capital\n    \n    def change_labor(self):\n        change_of_labor = self.labor[-1]*0.03\n        return change_of_labor\n    \n    def timestep(self):\n        capital_change = self.change_capital()\n        capital_new = self.capital[-1] + capital_change\n        self.capital.append(capital_new)\n        \n        labor_change = self.change_labor()\n        labor_new = self.labor[-1] + labor_change\n        self.labor.append(labor_new)\n        \n        bip_new = self.cobb_douglas(self.capital[-1], self.labor[-1])\n        self.bip.append(bip_new)\n\nexpl_econ = Economy(0.25, 5, 10)\nexpl_econ\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n<__main__.Economy at 0x118c6cfd0>\n```\n:::\n:::\n\n\n**Sechster Schritt: Die run Funktion**: Das ist der letzte Schritt.\nDefiniert eine Funktion `run`, die als Argument die Anzahl der Zeitschritte nimmt, und dann `capital`, `labor` und `bip` für die Anzahl der Zeitschritte neu berechnet.\nIn jedem Zeitschritt soll die Funktion `timestep` aufgerufgen werden.\n\n*Hinweis:*\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nclass Economy:\n    \n    def run(self, ):\n        for t in range( ):\n            print(t)\n            self. \n```\n:::\n\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nclass Economy:\n    \"\"\"\n    An economy.\n    \"\"\"\n    def __init__(self, alpha, capital, labor):\n        self.alpha = alpha\n        self.capital = [capital]\n        self.labor = [labor]\n        self.bip = []\n        self.bip.append(self.cobb_douglas(self.capital[-1], self.labor[-1]))\n    \n    def cobb_douglas(self, capital, labor):\n        bip = capital**self.alpha * labor**(1-self.alpha)\n        return bip\n    \n    def change_capital(self):\n        change_of_capital = self.bip[-1]*0.05 - self.capital[-1]*0.06\n        return change_of_capital\n    \n    def change_labor(self):\n        change_of_labor = self.labor[-1]*0.03\n        return change_of_labor\n    \n    def timestep(self):\n        capital_change = self.change_capital()\n        capital_new = self.capital[-1] + capital_change\n        self.capital.append(capital_new)\n        \n        labor_change = self.change_labor()\n        labor_new = self.labor[-1] + labor_change\n        self.labor.append(labor_new)\n        \n        bip_new = self.cobb_douglas(self.capital[-1], self.labor[-1])\n        self.bip.append(bip_new)\n    \n    def run(self, t_steps):\n        for t in range(t_steps):\n            print(t)\n            self.timestep()\n```\n:::\n\n\n**Siebter Schritt** Erstellt eine Instanz eurer Ökonomie, lasst das Modell für 10 Zeitschritte laufen, und lasst euch die finalen Werte für `capital`, `labor` und `bip` ausgeben. Ihr könnt hier folgendes Muster verwenden:\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nexpl_econ = Economy(0.4, 5, )\nexpl_econ.run( )\n```\n:::\n\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\nexpl_econ = Economy(0.4, 5, 8)\nexpl_econ.run(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n:::\n:::\n\n\nHier sind die relevanten Statusvariablen:\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\nexpl_econ.labor\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n[8,\n 8.24,\n 8.4872,\n 8.741816,\n 9.00407048,\n 9.274192594399999,\n 9.552418372232,\n 9.83899092339896,\n 10.13416065110093,\n 10.438185470633957,\n 10.751331034752976]\n```\n:::\n:::\n\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\nexpl_econ.capital\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n[5,\n 5.031445401733999,\n 5.06778191105444,\n 5.108982601976881,\n 5.155029407627849,\n 5.205912785920756,\n 5.261631412835216,\n 5.322191901872839,\n 5.3876085483457805,\n 5.457903097233226,\n 5.533104533415775]\n```\n:::\n:::\n\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nexpl_econ.bip\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n[6.628908034679974,\n 6.764464668489624,\n 6.9053521117141425,\n 7.0517152353916135,\n 7.203702855011553,\n 7.361467881394116,\n 7.525167476154716,\n 7.694963211706246,\n 7.871021235763835,\n 8.053512440330865,\n 8.242612635159615]\n```\n:::\n:::\n\n\nWir können das auch visualisieren (mehr dazu aber in einer späteren Session):\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport numpy as np\nfig, axes = plt.subplots(3,1)\n\naxes[0].plot(np.linspace(0, 10, 11), expl_econ.labor)\naxes[0].title.set_text(\"Labor dynamics\")\naxes[1].plot(np.linspace(0, 10, 11), expl_econ.capital)\naxes[1].title.set_text(\"Capital dynamics\")\naxes[2].plot(np.linspace(0, 10, 11), expl_econ.bip)\naxes[2].title.set_text(\"BIP dynamics\")\nfig.tight_layout()\n```\n\n::: {.cell-output .cell-output-display}\n![](Block-2-Loesungen_files/figure-pdf/cell-34-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n",
    "supporting": [
      "Block-2-Loesungen_files"
    ],
    "filters": []
  }
}